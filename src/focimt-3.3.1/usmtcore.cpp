//-----------------------------------------------------------------------------
// Source: usmtcore.cpp
// Module: focimt
// Moment tensor inversion core.
//
// Copyright (c) 2013-2017, Grzegorz Kwiatek.
//
// These routines were mostly translated to C++ from FORTRAN program USMT
// (Unix Seismic Moment Tensor) program by dr Pawel Wiejacz from Institute of
// Geophysics, Polish Academy of Sciences).
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------
#include "usmtcore.h"
#include <fstream>
//-----------------------------------------------------------------------------

#define USMT_UPSCALE (1.0e+12)
#define USMT_DOWNSCALE (1.0e-12)

using namespace Taquart::UsmtCore;
using namespace Taquart;

namespace Taquart {
  namespace UsmtCore {
    int NDAE[10] = { 0, 36, 36, 32, 32, 24, 24, 16, 8, 4 };
    double U[FOCIMT_MAXCHANNEL + 1];
    double AZM[FOCIMT_MAXCHANNEL + 1];
    double TKF[FOCIMT_MAXCHANNEL + 1];
    double GA[FOCIMT_MAXCHANNEL + 1][3 + 1];
    double A[FOCIMT_MAXCHANNEL + 1][6 + 1];
    double FIJ[3 + 1][3 + 1][FOCIMT_MAXCHANNEL + 1];
    double RM[6 + 1][3 + 1];
    double COV[6 + 1][6 + 1][3 + 1];
    int RO[FOCIMT_MAXCHANNEL + 1];
    int VEL[FOCIMT_MAXCHANNEL + 1];
    int R[FOCIMT_MAXCHANNEL + 1];
    double UTH[FOCIMT_MAXCHANNEL + 1][3 + 1];
    Taquart::String Station[FOCIMT_MAXCHANNEL + 1];
    int N = 0;
    double TROZ = 0.0;
    double QSD = 0.0;
    double QF = 0.0;
    bool FSTCLL = true;
    int ICOND = 0;
    Taquart::FaultSolution Solution[4];
    int ISTA = 1;
  //int * ThreadProgress;
  }// namespace UsmtCore
} // namespace Foci

//---------------------------------------------------------------------------
void TransferSolution(Taquart::SolutionType AType,
    std::list<Taquart::FaultSolution> &ASolution) {
  ASolution.push_back(Taquart::UsmtCore::Solution[int(AType)]);
}

//---------------------------------------------------------------------------
void TransferSolution(Taquart::SolutionType AType,
    Taquart::FaultSolution &ASolution) {
  ASolution = Taquart::UsmtCore::Solution[int(AType)];
}

Taquart::FaultSolution TransferSolution(Taquart::SolutionType AType) {
  return Taquart::UsmtCore::Solution[int(AType)];
}

//---------------------------------------------------------------------------
double Taquart::UsmtCore::mw(double m0) {
  double RMAG = 2.0 * alog10(m0) / 3.0 - 6.03;
  if (RMAG >= 100.0)
    RMAG = 99.9;
  if (RMAG < -10.0)
    RMAG = -9.9;
  return RMAG;
}

//---------------------------------------------------------------------------
void USMTCore(Taquart::NormType ANormType, int QualityType,
    Taquart::SMTInputData &InputData) {
  int IEXP = 0;
  //ThreadProgress = AThreadProgress;
  PROGRESS(0, 350);
  RDINP(InputData);
  ANGGA();
  JEZ();
  switch (ANormType) {
    case Taquart::ntL1:
      MOM2(false, QualityType);
      SIZEMM(IEXP);
      MOM1(IEXP, QualityType);
      break;
    case Taquart::ntL2:
      MOM2(true, QualityType);
      break;
  }
  PROGRESS(360, 350);
}

//---------------------------------------------------------------------------
void Taquart::UsmtCore::MOM1(int &IEXP, int QualityType) {
  //      SUBROUTINE MOM1(IEXP)
  //      CHARACTER PS(80),TITLE*40
  //      REAL U(80),ARR(80),AZM(80),TKF(80),LLA(3),HA(2)
  //      INTEGER RO(80),VEL(80),R(80)
  //      COMMON/MDATA/ PS,U,ARR,AZM,TKF,RO,VEL,R,TITLE,N,TROZ
  //      COMMON/GAGAGA/ GA(80,3)
  //      COMMON/RESTEX/ RESULT
  //      CHARACTER*56 RESULT(34)
  //      COMMON/MOMNT/ RM(6,3)
  //      DOUBLE PRECISION DHELP1,DHELP2,COV
  //      COMMON/PDATA/ A(80,6)
  //      DIMENSION EQM(3),AA(80,6),B(6),H(5),IW(80),PA(3),BB(6)
  //      REAL RM0(3),RMT(3),PCLVD(2),PDBCP(2)
  double AA[FOCIMT_MAXCHANNEL + 1][6 + 1];
  unsigned int IW[FOCIMT_MAXCHANNEL + 1];
  double PA[3 + 1];
  Zero(PA, 4);
  double EQM[3 + 1];
  Zero(EQM, 4);
  double BB[6 + 1];
  Zero(BB, 7);
  double RM0[3 + 1];
  Zero(RM0, 4);
  double RMT[3 + 1];
  Zero(RMT, 4);
  double RMERR[3 + 1];
  Zero(RMERR, 4);
  double PEXPL[3 + 1];
  Zero(PEXPL, 4);
  double PCLVD[3 + 1];
  Zero(PCLVD, 4);
  double PDBCP[3 + 1];
  Zero(PDBCP, 4);
  double PEXPL_VAC[3 + 1];
  Zero(PEXPL_VAC, 4);
  double PCLVD_VAC[3 + 1];
  Zero(PCLVD_VAC, 4);
  double PDBCP_VAC[3 + 1];
  Zero(PDBCP_VAC, 4);
  double B[7];
  Zero(B, 7);
  double H[5 + 1];
  Zero(H, 6);
  double ALF = 0.0;
  double HELP = 0.0;
  double PEXPLO = 0.0;
  double RMAG = 0.0;
  double MAGN[4];

  const double PI = 4.0 * atan(1.0);

  //      DO 3 I=1,N
  for (int i = 1; i <= N; i++) {
    //      IW(I)=0
    //      IF((PS(I).EQ.'S').OR.(PS(I).EQ.'s')) IW(I)=1
    //      IF((PS(I).EQ.'H').OR.(PS(I).EQ.'h')) IW(I)=2
    //      ALF=FLOAT(VEL(I))
    //      HELP=4.*PI*FLOAT(RO(I))*ALF*ALF*ALF*FLOAT(R(I))*TROZ
    IW[i] = 0;
    //if(PS[i] == 'S' || PS[i] == 's') IW[i] = 1;
    //if(PS[i] == 'H' || PS[i] == 'h') IW[i] = 2;
    ALF = VEL[i];
    /* DONE  5 -c2.4.14 : Problem z kalibracją (USMTCORE) */
    HELP = 4.0 * PI * double(RO[i]) * ALF * ALF * ALF * double(R[i]);

    //      IF(IW(I).NE.0) GO TO 5
    if (IW[i] == 0) {
      //C     For P:
      //      A(I,1)=GA(I,1)*GA(I,1)/HELP
      //      A(I,2)=2.*GA(I,1)*GA(I,2)/HELP
      //      A(I,3)=2.*GA(I,1)*GA(I,3)/HELP
      //      A(I,4)=GA(I,2)*GA(I,2)/HELP
      //      A(I,5)=2.*GA(I,2)*GA(I,3)/HELP
      //      A(I,6)=GA(I,3)*GA(I,3)/HELP
      //      GO TO 3
      A[i][1] = GA[i][1] * GA[i][1] / HELP;
      A[i][2] = 2.0 * GA[i][1] * GA[i][2] / HELP;
      A[i][3] = 2.0 * GA[i][1] * GA[i][3] / HELP;
      A[i][4] = GA[i][2] * GA[i][2] / HELP;
      A[i][5] = 2.0 * GA[i][2] * GA[i][3] / HELP;
      A[i][6] = GA[i][3] * GA[i][3] / HELP;
    }

    /* Code for SV and SH is switched off by default. */
    /*
     else
     {
     //C     For SV:
     //    5 SVANG=REAL(ARR(I))*PI/180.
     //      PA(3)=-SIN(SVANG)
     //      SKAL=-COS(SVANG)/SQRT(GA(I,1)*GA(I,1)+GA(I,2)*GA(I,2))
     //      PA(1)=GA(I,1)*SKAL
     //      PA(2)=GA(I,2)*SKAL
     double SVANG = double(ARR[i]) * PI / 180.0;
     PA[3] = -sin(SVANG);
     const double SKAL = -cos(SVANG) / sqrt(GA[i][1] * GA[i][1] + GA[i][2] * GA[i][2]);
     PA[1] = GA[i][1] * SKAL;
     PA[2] = GA[i][2] * SKAL;

     //      IF(IW(I).EQ.2) GO TO 6
     if(IW[i] != 2)
     {
     //      A(I,1)=GA(I,1)*PA(1)/HELP
     //      A(I,2)=(GA(I,1)*PA(2)+GA(I,2)*PA(1))/HELP
     //      A(I,3)=(GA(I,1)*PA(3)+GA(I,3)*PA(1))/HELP
     //      A(I,4)=GA(I,2)*PA(2)/HELP
     //      A(I,5)=(GA(I,2)*PA(3)+GA(I,3)*PA(2))/HELP
     //      A(I,6)=GA(I,3)*PA(3)/HELP
     //      GO TO 3
     A[i][1]=GA[i][1]*PA[1]/HELP;
     A[i][2]=(GA[i][1]*PA[2]+GA[i][2]*PA[1])/HELP;
     A[i][3]=(GA[i][1]*PA[3]+GA[i][3]*PA[1])/HELP;
     A[i][4]=GA[i][2]*PA[2]/HELP;
     A[i][5]=(GA[i][2]*PA[3]+GA[i][3]*PA[2])/HELP;
     A[i][6]=GA[i][3]*PA[3]/HELP;
     }
     else
     {
     //C     For SH:
     //    6 LLA(3)=-COS(SVANG)
     //      SKAL=SIN(SVANG)/SQRT(GA(I,1)*GA(I,1)+GA(I,2)*GA(I,2))
     //      LLA(1)=GA(I,1)*SKAL
     //      LLA(2)=GA(I,2)*SKAL
     //      HA(1)=LLA(2)*PA(3)-LLA(3)*PA(2)
     //      HA(2)=-LLA(1)*PA(3)+LLA(3)*PA(1)
     //      A(I,1)=GA(I,1)*HA(1)/HELP+LLA(3)*GA(I,1)*PA(1)/HELP
     //      A(I,2)=(GA(I,1)*HA(2)+GA(I,2)*HA(1))/HELP
     //     $+LLA(3)*(GA(I,1)*PA(2)+GA(I,2)*PA(1))/HELP
     //      A(I,3)=GA(I,3)*HA(1)/HELP+LLA(3)*(GA(I,1)*PA(3)+GA(I,3)*PA(1))
     //     $/HELP
     //      A(I,4)=GA(I,2)*HA(2)/HELP+LLA(3)*GA(I,2)*PA(2)/HELP
     //      A(I,5)=GA(I,3)*HA(2)/HELP+LLA(3)*(GA(I,2)*PA(3)+GA(I,3)*PA(2))
     //     $/HELP
     //      A(I,6)=+LLA(3)*GA(I,3)*PA(3)/HELP
     double LLA[4];
     double HA[4];

     LLA[3]=-cos(SVANG);
     double SKAL = sin(SVANG)/sqrt(GA[i][1]*GA[i][1]+GA[i][2]*GA[i][2]);
     LLA[1]=GA[i][1]*SKAL;
     LLA[2]=GA[i][2]*SKAL;
     HA[1]=LLA[2]*PA[3]-LLA[3]*PA[2];
     HA[2]=-LLA[1]*PA[3]+LLA[3]*PA[1];
     A[i][1]=GA[i][1]*HA[1]/HELP+LLA[3]*GA[i][1]*PA[1]/HELP;
     A[i][2]=(GA[i][1]*HA[2]+GA[i][2]*HA[1])/HELP+LLA[3]*(GA[i][1]*PA[2]+GA[i][2]*PA[1])/HELP;
     A[i][3]=GA[i][3]*HA[1]/HELP+LLA[3]*(GA[i][1]*PA[3]+GA[i][3]*PA[1])/HELP;
     A[i][4]=GA[i][2]*HA[2]/HELP+LLA[3]*GA[i][2]*PA[2]/HELP;
     A[i][5]=GA[i][3]*HA[2]/HELP+LLA[3]*(GA[i][2]*PA[3]+GA[i][3]*PA[2])/HELP;
     A[i][6]=+LLA[3]*GA[i][3]*PA[3]/HELP;
     }
     }
     */
  }

  //---- Full solution calculation.
  GSOL(B, IEXP);
  EIG3(B, 0, EQM);

  double EQQ1 = EQM[1];
  double EQQ2 = EQM[2];
  double EQQ3 = EQM[3];

  for (int i = 1; i <= 6; i++)
    RM[i][1] = B[i];

  double RMY = EQM[1];
  if (EQM[2] < RMY)
    RMY = EQM[2];
  if (EQM[3] < RMY)
    RMY = EQM[3];
  double RMX = EQM[3];

  if (EQM[1] > RMX)
    RMX = EQM[1];
  if (EQM[2] > RMX)
    RMX = EQM[2];

  for (int i = 1; i <= 6; i++)
    BB[i] = RM[i][1];

  EIG3(BB, 0, EQM);
  EQM[1] = fabs(EQM[1]) * USMT_DOWNSCALE;
  EQM[2] = fabs(EQM[2]) * USMT_DOWNSCALE;
  EQM[3] = fabs(EQM[3]) * USMT_DOWNSCALE;
  double HELP1 = fabs(EQM[1] - EQM[2]);
  double HELP2 = fabs(EQM[1] - EQM[3]);
  double HELP3 = fabs(EQM[2] - EQM[3]);

  double EU = sqrt(0.5 * (EQM[1] * EQM[1] + EQM[2] * EQM[2] + EQM[3] * EQM[3]));
  double EC = Taquart::amax1(HELP1, HELP2);
  EC = amax1(EC, HELP3);
  RMT[1] = amax1(EC, EU) * USMT_UPSCALE;
  RM0[1] = amin1(EC, EU) * USMT_UPSCALE;

  // Error calculation.
  for (int i = 1; i <= N; i++) {
    double EPS = U[i];
    //---- Calculate theoretical displacement.
    UTH[i][1] = 0.0f;
    for (int j = 1; j <= 6; j++)
      UTH[i][1] += A[i][j] * RM[j][1];
    //---- Calculate theoretical displacement.
    for (int j = 1; j <= 6; j++)
      EPS = EPS - A[i][j] * RM[j][1];
    double SAI = 0.0;
    for (int j = 1; j <= 6; j++)
      SAI = SAI + fabs(A[i][j]);
    for (int j = 1; j <= 6; j++)
      AA[i][j] = EPS / SAI * sign(1.0, A[i][j]);
    for (int j = 1; j <= 6; j++)
      AA[i][j] = AA[i][j] + RM[j][1];
  }

  double COV = 0.0;
  for (int i = 1; i <= 6; i++) {
    for (int j = 1; j <= 6; j++) {
      for (int k = 1; k <= N; k++) {
        double DHELP1 = (AA[k][i] - RM[i][1]) * USMT_DOWNSCALE;
        double DHELP2 = (AA[k][j] - RM[j][1]) * USMT_DOWNSCALE;
        COV = COV + DHELP1 * DHELP2;
      }
    }
  }

  COV = COV / 36.0;
  double DHELP1 = fabs(COV) / double(N - 1);
  double SIG = sqrt(DHELP1) * USMT_UPSCALE;
  RMERR[1] = SIG;

#ifdef USMTCORE_DEBUG
  std::cout << "L1 Tensor:" << std::endl;
  std::cout << RM[1][1] << RM[2][1] << RM[3][1] << std::endl;
  std::cout << RM[2][1] << RM[4][1] << RM[5][1] << std::endl;
  std::cout << RM[3][1] << RM[5][1] << RM[6][1] << std::endl;
  std::cout << "T0 = " << TROZ << " M0 = " << RM0[1] << " MT = " << RMT[1] << " ERR = " << SIG;
#endif

  // Full moment tensor solution, norm L1.
  Solution[1].E[0] = EQQ1;
  Solution[1].E[1] = EQQ2;
  Solution[1].E[2] = EQQ3;
  EIGGEN(EQQ1, EQQ2, EQQ3, PEXPLO, PCLVD[1], PDBCP[1], PEXPL_VAC[1],
      PCLVD_VAC[1], PDBCP_VAC[1]);
  RMAG = mw(RM0[1]);
  MAGN[1] = RMAG;

#ifdef USMTCORE_DEBUG
  std::cout << " EXPL = " << PEXPL << " PCLVD = " << PCLVD[1];
  std::cout << " PDBCP = " << PDBCP[1] << " Mw = " << RMAG << std::endl;
#endif

  PEXPL[1] = PEXPLO;

  //---- Trace-null solution calculation.
  GSOL5(H, IEXP);

  for (int i = 1; i <= 5; i++)
    RM[i][2] = H[i];
  RM[6][2] = -RM[1][2] - RM[4][2];

  for (int i = 1; i <= 6; i++)
    B[i] = RM[i][2];
  EIG3(B, 0, EQM);

  EQQ1 = EQM[1];
  EQQ2 = EQM[2];
  EQQ3 = EQM[3];
  RMY = EQM[1];
  if (EQM[2] < RMY)
    RMY = EQM[2];
  if (EQM[3] < RMY)
    RMY = EQM[3];
  RMX = EQM[3];

  if (EQM[1] > RMX)
    RMX = EQM[1];
  if (EQM[2] > RMX)
    RMX = EQM[2];

  // Find scalar seismic moment.
  for (int i = 1; i <= 6; i++)
    BB[i] = RM[i][2];

  EIG3(BB, 0, EQM);
  EQM[1] = fabs(EQM[1]) * USMT_DOWNSCALE;
  EQM[2] = fabs(EQM[2]) * USMT_DOWNSCALE;
  EQM[3] = fabs(EQM[3]) * USMT_DOWNSCALE;
  HELP1 = fabs(EQM[1] - EQM[2]);
  HELP2 = fabs(EQM[1] - EQM[3]);
  HELP3 = fabs(EQM[2] - EQM[3]);
  EU = sqrt(0.5 * (EQM[1] * EQM[1] + EQM[2] * EQM[2] + EQM[3] * EQM[3]));
  EC = amax1(HELP1, HELP2);
  EC = amax1(EC, HELP3);
  RMT[2] = amax1(EC, EU) * USMT_UPSCALE;
  RM0[2] = amin1(EC, EU) * USMT_UPSCALE;

  // Error calculation.
  for (int i = 1; i <= N; i++) {
    double EPS = U[i];
    //---- Calculate theoretical displacement.
    UTH[i][2] = 0.0f;
    for (int j = 1; j <= 6; j++)
      UTH[i][2] += A[i][j] * RM[j][2];
    //---- Calculate theoretical displacement.
    for (int j = 1; j <= 6; j++)
      EPS = EPS - A[i][j] * RM[j][2];
    double SAI = 0.0;
    for (int j = 1; j <= 6; j++)
      SAI = SAI + fabs(A[i][j]);
    for (int j = 1; j <= 6; j++)
      AA[i][j] = EPS / SAI * sign(1.0, A[i][j]);
    for (int j = 1; j <= 6; j++)
      AA[i][j] = AA[i][j] + RM[j][2];
  }

  COV = 0.0;
  for (int i = 1; i <= 6; i++) {
    for (int j = 1; j <= 6; j++) {
      for (int k = 1; k <= N; k++) {
        double DHELP1 = (AA[k][i] - RM[i][2]) * USMT_DOWNSCALE;
        double DHELP2 = (AA[k][j] - RM[j][2]) * USMT_DOWNSCALE;
        COV = COV + DHELP1 * DHELP2;
      }
    }
  }

  COV = COV / 36.0;
  DHELP1 = fabs(COV) / double(N - 1);
  SIG = sqrt(DHELP1) * USMT_UPSCALE;
  RMERR[2] = SIG;

#ifdef USMTCORE_DEBUG
  std::cout << RM[1][2] << RM[2][2] << RM[3][2] << std::endl;
  std::cout << RM[2][2] << RM[4][2] << RM[5][2] << std::endl;
  std::cout << RM[3][2] << RM[5][2] << RM[6][2] << std::endl;
  std::cout << "T0 = " << TROZ << " M0 = " << RM0[2] << " MT = " << RMT[2] << " ERR = " << SIG;
#endif

  double DUM = 0.0;
  // Trace-null moment tensor solution, norm L1.
  Solution[2].E[0] = EQQ1;
  Solution[2].E[1] = EQQ2;
  Solution[2].E[2] = EQQ3;
  EIGGEN(EQQ1, EQQ2, EQQ3, DUM, PCLVD[2], PDBCP[2], DUM, PCLVD_VAC[2],
      PDBCP_VAC[2]);
  RMAG = mw(RM0[2]);
  MAGN[2] = RMAG;

#ifdef USMTCORE_DEBUG
  std::cout << " PCLVD = " << PCLVD[2];
  std::cout << " PDBCP = " << PDBCP[2] << " Mw = " << RMAG << std::endl;
#endif

  PEXPL[2] = 0.0;

  //---- Double-couple solution calculation.
  GSOLA(H, IEXP);
  for (int i = 1; i <= 5; i++)
    RM[i][3] = H[i];
  RM[6][3] = -RM[1][3] - RM[4][3];

  // Finds scalar seismic moment.
  for (int i = 1; i <= 6; i++)
    BB[i] = RM[i][3];

  EIG3(BB, 0, EQM);
  EQQ1 = EQM[1];
  EQQ2 = EQM[2];
  EQQ3 = EQM[3];
  EQM[1] = fabs(EQM[1]) * USMT_DOWNSCALE;
  EQM[2] = fabs(EQM[2]) * USMT_DOWNSCALE;
  EQM[3] = fabs(EQM[3]) * USMT_DOWNSCALE;
  HELP1 = fabs(EQM[1] - EQM[2]);
  HELP2 = fabs(EQM[1] - EQM[3]);
  HELP3 = fabs(EQM[2] - EQM[3]);
  EC = amax1(HELP1, HELP2);
  EC = amax1(EC, HELP3);
  RMT[3] = EC * USMT_UPSCALE;
  RM0[3] = RMT[3];

  // Error calculation.
  for (int i = 1; i <= N; i++) {
    double EPS = U[i];
    //---- Calculate theoretical displacement.
    UTH[i][3] = 0.0f;
    for (int j = 1; j <= 6; j++)
      UTH[i][3] += A[i][j] * RM[j][3];
    //---- Calculate theoretical displacement.
    for (int j = 1; j <= 6; j++)
      EPS = EPS - A[i][j] * RM[j][3];
    double SAI = 0.0;
    for (int j = 1; j <= 6; j++)
      SAI = SAI + fabs(A[i][j]);
    for (int j = 1; j <= 6; j++)
      AA[i][j] = EPS / SAI * sign(1.0, A[i][j]);
    for (int j = 1; j <= 6; j++)
      AA[i][j] = AA[i][j] + RM[j][3];
  }

  COV = 0.0;
  for (int i = 1; i <= 6; i++) {
    for (int j = 1; j <= 6; j++) {
      for (int k = 1; k <= N; k++) {
        double DHELP1 = (AA[k][i] - RM[i][3]) * USMT_DOWNSCALE;
        double DHELP2 = (AA[k][j] - RM[j][3]) * USMT_DOWNSCALE;
        COV = COV + DHELP1 * DHELP2;
      }
    }
  }

  // Double-couple moment tensor solution, norm L1.
  Solution[3].E[0] = EQQ1;
  Solution[3].E[1] = EQQ2;
  Solution[3].E[2] = EQQ3;

  COV = COV / 36.0;
  DHELP1 = fabs(COV) / double(N - 1);
  SIG = sqrt(DHELP1) * USMT_UPSCALE;
  RMERR[3] = SIG;

#ifdef USMTCORE_DEBUG
  std::cout << RM[1][3] << RM[2][3] << RM[3][3] << std::endl;
  std::cout << RM[2][3] << RM[4][3] << RM[5][3] << std::endl;
  std::cout << RM[3][3] << RM[5][3] << RM[6][3] << std::endl;
  std::cout << "T0 = " << TROZ << " M0 = " << RM0[3] << " MT = " << RMT[3] << " ERR = " << SIG;
#endif

  RMAG = mw(RM0[3]);
  MAGN[3] = RMAG;

#ifdef USMTCORE_DEBUG
  std::cout << " PDBCP = 100% Mw = " << RMAG << std::endl;
#endif

  PEXPL[3] = 0.0;
  PCLVD[3] = 0.0;
  PDBCP[3] = 100.0;

  PEXPL_VAC[3] = 0.0;
  PCLVD_VAC[3] = 0.0;
  PDBCP_VAC[3] = 100.0;

  // Transfer data to output structure
  for (int i = 1; i <= N; i++) {
    Solution[1].U_n = N;
    Solution[2].U_n = N;
    Solution[3].U_n = N;
    Solution[1].U_th[i - 1] = UTH[i][1];
    Solution[2].U_th[i - 1] = UTH[i][2];
    Solution[3].U_th[i - 1] = UTH[i][3];
    Solution[1].U_measured[i - 1] = U[i];
    Solution[2].U_measured[i - 1] = U[i];
    Solution[3].U_measured[i - 1] = U[i];
    Solution[1].Station[i - 1] = Station[i];
    Solution[2].Station[i - 1] = Station[i];
    Solution[3].Station[i - 1] = Station[i];
  }

  //std::ofstream file("file.txt",std::ofstream::out | std::ofstream::app);
  for (int q = 1; q <= 3; q++) {
    double up = 0.0;
    double down = 0.0;
    for (int i = 1; i <= N; i++) {
      //file << UTH[i][q] << " " << U[i] << std::endl;
      up += ((UTH[i][q] - U[i]) * (UTH[i][q] - U[i]));
      down += (U[i] * U[i]);
    }
    if (down == 0.0)
      Solution[q].UERR = 0.0;
    else
      Solution[q].UERR = sqrt(up / down);
  }
  //file.close();

  for (int i = 1; i <= 3; i++) {
    int z = 0;
    int v[] = { 1, 2, 3, 2, 4, 5, 3, 5, 6 };
    for (int m = 1; m <= 3; m++)
      for (int n = 1; n <= 3; n++) {
        Solution[i].M[m][n] = RM[v[z]][i];
        z++;
      }

    Solution[i].T0 = TROZ;
    Solution[i].M0 = RM0[i];
    Solution[i].MT = RMT[i];
    Solution[i].ERR = RMERR[i];
    Solution[i].EXPL = PEXPL[i];
    Solution[i].CLVD = PCLVD[i];
    Solution[i].DBCP = PDBCP[i];
    Solution[i].EXPL_VAC = PEXPL_VAC[i];
    Solution[i].CLVD_VAC = PCLVD_VAC[i];
    Solution[i].DBCP_VAC = PDBCP_VAC[i];
    Solution[i].MAGN = MAGN[i];
    for (int m = 1; m <= 6; m++)
      for (int n = 1; n <= 6; n++)
        Solution[i].Covariance[m][n] = 0.0;
  }

  ICOND = 1;
  XTRINF(ICOND, 1, RM0, RMERR);
}

//-----------------------------------------------------------------------------
// Routine finds eigenvalues of matrix 3*3 by solving characteristic equation.
void Taquart::UsmtCore::EIG3(double RM[], int ISTER, double E[]) {
  //      DIMENSION RM(6),E(3)
  //      DOUBLE PRECISION A2,A1,A0,VAL,ONE,TWO,ZERO,A,B,X,Q(6)
  //      ZERO=DBLE(0.)
  //      ONE=DBLE(1.)
  //      TWO=DBLE(2.)
  double ZERO = 0.0, TWO = 2.0;
  double Q[6 + 1];
  Zero(Q, 6);
  double A2 = 0.0, A1 = 0.0, A0 = 0.0, VAL = 0.0, A = 0.0, B = 0.0, X = 0.0;
  double F = 0.0, G = 0.0, OX = 0.0, FF = 0.0, FG = 0.0, QX = 0.0, HELP = 0.0;
  double FX = 0.0;

  for (int i = 1; i <= 6; i++)
    Q[i] = RM[i];
  A2 = -(Q[1] + Q[4] + Q[6]);
  A1 = Q[1] * Q[6] + Q[4] * Q[6] + Q[1] * Q[4] - Q[2] * Q[2] - Q[3] * Q[3]
      - Q[5] * Q[5];
  A0 = -TWO * Q[2] * Q[3] * Q[5] - Q[1] * Q[4] * Q[6] + Q[3] * Q[3] * Q[4]
      + Q[2] * Q[2] * Q[6] + Q[5] * Q[5] * Q[1];
  A = -1.0e+30;
  B = 1.0e+30;
  X = ZERO;

  for (int KROK = 1; KROK <= 200; KROK++) {
    VAL = pow(X, 3.0) + A2 * pow(X, 2) + A1 * X + A0;
    if (VAL == ZERO)
      goto p3;
    if (VAL < ZERO)
      A = X;
    if (VAL > ZERO)
      B = X;
    X = (A + B) / TWO;
  }

  p3: A0 = A1 + A2 * X + X * X;
  A1 = A2 + X;
  VAL = A1 * A1 - TWO * TWO * A0;

  if (VAL < ZERO)
    VAL = ZERO;

  VAL = sqrt(VAL);
  A = (-A1 - VAL) / TWO;
  B = (-A1 + VAL) / TWO;
  E[1] = X;
  E[2] = A;
  E[3] = B;

  if (ISTER == 0)
    return;

  for (int i = 1; i <= 3; i++) {
    int iter = 0;
    F = 0.0;
    G = 0.0;
    if (E[i] == 0.0) {
      F = -1.0e-06;
      G = +1.0e-06;
    }
    else {
      F = E[i] * 0.999;
      G = E[i] * 1.001;
    }
    OX = F;

    p7: FF = DETR(RM, F);
    FG = DETR(RM, G);
    QX = (F + G) / 2.0;
    iter = iter + 1;

    if (iter > 1000)
      continue;

    //      IF(ABS((QX-OX)/E(I)).LT.1.E-06) GO TO 8

    /* DONE 5 -c2.4.8 : Correction for the /div0 error. */
    double ee = (E[i] == 0.0) ? 1.0e-6 : E[i];
    //--------------------------------------
    if (fabs((QX - OX) / ee) < 1.0e-6)
      goto p8;

    HELP = FF * FG;

    if (HELP > 0.0)
      goto p9;
    FX = DETR(RM, QX);
    HELP = FF * FX;
    if (HELP < 0.0) {
      G = QX;
    }
    else {
      F = QX;
    }
    OX = QX;
    goto p7;

    p9: F = 0.999 * F;
    G = 1.001 * G;
    goto p7;

    p8: E[i] = QX;
  }
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::EIGGEN_NEW(double e1, double e2, double e3, double &iso,
    double &clvd, double &dbcp, double &iso_vav, double &clvd_vav,
    double &dbcp_vav) {
  const double trace = (e1 + e2 + e3) / 3.0;
  const double e1a = fabs(e1 - trace);
  const double e2a = fabs(e2 - trace);
  const double e3a = fabs(e3 - trace);
  double v1 = 0.0, v3 = 0.0;

  // Find the largest absolute deviatoric eigenvalue.
  if (e1a >= e2a && e1a >= e3a) {
    v1 = e1 - trace;
  }
  if (e2a >= e1a && e2a >= e3a) {
    v1 = e2 - trace;
  }
  if (e3a >= e1a && e3a >= e2a) {
    v1 = e3 - trace;
  }

  // Fint the smallest...
  if (e1a <= e2a && e1a <= e3a) {
    v3 = e1 - trace;
  }
  if (e2a <= e1a && e2a <= e3a) {
    v3 = e2 - trace;
  }
  if (e3a <= e1a && e3a <= e2a) {
    v3 = e3 - trace;
  }

  // v1 - largest absolute deviatoric eigenvalue  of MT
  // v3 - smallest absolute deviatoric eigenvalue of MT

  // Percentage of ISO/CLVD/DC moment tensor components according to the
  // procedure of Vavrycuk (2001):

  const double eigv_abs_max =
      ((fabs(e1) > fabs(e2)) ? fabs(e1) : fabs(e2)) > (fabs(e3)) ?
          ((fabs(e1) > fabs(e2)) ? fabs(e1) : fabs(e2)) : fabs(e3);
  const double epsilon = -v3 / v1;
  iso_vav = 100 * trace / eigv_abs_max;
  clvd_vav = 2 * (v1 > 0.0 ? 1.0 : (v1 < 0 ? -1.0 : 0.0)) * epsilon
      * (100.0 - fabs(iso_vav));
  dbcp_vav = 100 - fabs(iso_vav) - fabs(clvd_vav);

  // The percentage of moment tensor components is calculated with the method
  // of Jost and Herrmann (1989):
  const double ff = -v3 / v1;
  iso = trace;
  clvd = 2 * v1 * ff;
  dbcp = fabs(v1 * (1.0 - 2.0 * ff));
  const double s = fabs(iso) + fabs(clvd) + fabs(dbcp);
  iso = iso / s * 100.0;
  clvd = clvd / s * 100.0;
  dbcp = dbcp / s * 100.0;
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::EIGGEN(double &E1, double &E2, double &E3, double &ALFA,
    double &BETA, double &GAMA, double &iso_vav, double &clvd_vav,
    double &dbcp_vav) {
  EIGGEN_NEW(E1, E2, E3, ALFA, BETA, GAMA, iso_vav, clvd_vav, dbcp_vav);
  /*
   int IA = 1;
   double EA = E1;
   double EB = 0.0;
   int IB = 0;
   double EC = 0.0;
   int IC = 0;

   if(EA >= E2)
   {
   EA = E2;
   IA = 2;
   }
   if(EA >= E3)
   {
   EA = E3;
   IA = 3;
   }
   if(IA == 1)
   {
   EB = E2;
   IB = 2;
   if(EB > E3) goto p3;
   EB = E3;
   IB = 3;
   goto p3;
   }

   if(IA != 3)
   {
   EB = E1;
   IB = 1;
   if(EB > E3) goto p3;
   EB = E3;
   IB = 3;
   goto p3;
   }
   else
   {
   EB = E1;
   IB = 1;
   if(EB > E2) goto p3;
   EB = E2;
   IB = 2;
   }

   p3: IC = 6 - IA - IB;
   if(IC == 1) EC = E1;
   if(IC == 2) EC = E2;
   if(IC == 3) EC = E3;

   ALFA = (E1 + E2 + E3) / 3.0;
   BETA = ALFA - EC;
   GAMA = EC - EA;
   ALFA = ALFA * 1.0e-12;
   BETA = BETA * 1.0e-12;
   GAMA = GAMA * 1.0e-12;

   const double skal = fabs(ALFA) + fabs(BETA) + fabs(GAMA);
   ALFA = ALFA / skal * 100.0;
   BETA = BETA / skal * 100.0;
   GAMA = GAMA / skal * 100.0;
   */
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::XTRINF(int &ICOND, int LNORM, double Moment0[],
    double MomentErr[]) {
  //      SUBROUTINE XTRINF(ICOND)
  //      CHARACTER PS(80),TITLE*40
  //      REAL U(80),ARR(80),AZM(80),TKF(80),ETA(3),RKAPPA(3),VALKAP(3),
  //     $B(6),EQM(3),V(3,3,3),RNU(3),PLUNGE(3,3),TREND(3,3),X(3),Y(3),
  //     $STRIKE(3,2),DIP(3,2)
  //      INTEGER RO(80),VEL(80),R(80)
  //      INTEGER*2 QF
  //      COMMON/MDATA/ PS,U,ARR,AZM,TKF,RO,VEL,R,TITLE,N,TROZ
  //      COMMON/MOMNT/ RM(6,3)
  //      COMMON/JEZQUA/ QSD,QF
  //      COMMON/RESTEX/ RESULT
  //      CHARACTER*56 RESULT(34)
  //      DOUBLE PRECISION COV(6,6,3)
  //      COMMON/VCOVAR/ COV
  //      CHARACTER*13 INFO(3),INFFTD(3)
  //      DATA VALKAP/1.,.707,.5/
  //      DATA INFO/'normal  fault',' strike slip ',
  //     $'reverse fault'/

  //      SQR2=SQRT(2.)
  //      PI=4.*ATAN(1.)
  double SQR2 = sqrt(2.0);
  double PI = 4.0 * atan(1.0);
  double B[7];
  Zero(B, 7);
  double V[4][4][4];
  Zero(&V[0][0][0], 64);
  double EQM[4];
  Zero(EQM, 4);
  double X[4], Y[4];
  Zero(X, 4);
  Zero(Y, 4);
  double STRIKE[4][3];
  Zero(&STRIKE[0][0], 12);
  double DIP[4][3];
  Zero(&DIP[0][0], 12);
  double RAKE[4][3];
  Zero(&RAKE[0][0], 12);
  double PLUNGE[4][4];
  Zero(&PLUNGE[0][0], 16);
  double TREND[4][4];
  Zero(&TREND[0][0], 16);
  double AMP[4][4];
  Zero(&AMP[0][0], 16);

  String INFO[4] = { "", "NF", "SS", "TF" };
  String INFFTD[4];

  double ETA[4];
  double HELP = 0, HELP1 = 0.0, HELP2 = 0.0, HELP3 = 0.0;
  int IMIN = 0;
  int IMAX = 0;
  int j = 0;

  // Quality factor calculation.
  if (LNORM != 2) {
    for (int i = 1; i <= 3; i++)
      ETA[i] = 1.0 - MomentErr[i] / Moment0[i];
  }
  else {
    for (int i = 1; i <= 3; i++) {
      HELP1 = Moment0[i];
      HELP3 = 0.0;
      HELP2 = sqrt(COV[1][1][i]);
      for (int j = 2; j <= 6; j++) {
        HELP3 = sqrt(COV[j][j][i]);
        HELP2 = amax1(HELP2, HELP3);
      }
      ETA[i] = 1.0 - HELP2 / HELP1;
    }
  }
  double RNU[4];
  RNU[1] = double(N - 7) / double(N);
  RNU[2] = double(N - 6) / double(N);
  RNU[3] = double(N - 5) / double(N);

  if (ICOND <= 0 || ICOND > 3)
    ICOND = 1;
  const double VALKAP[4] = { 0.0, 1.0, 0.707, 0.5 };
  double RKAPPA[4] = { 0.0, 1.0, 1.0, VALKAP[ICOND] };

  for (int i = 1; i <= 3; i++) {
    if (ETA[i] < 0.0)
      ETA[i] = 0.01;
    ETA[i] = ETA[i] * RNU[i] * RKAPPA[i] * 100.0;
    if (QF != 0.0)
      ETA[i] = ETA[i] * QSD;
  }

  for (int i = 1; i <= 3; i++) {
    for (int j = 1; j <= 6; j++)
      B[j] = RM[j][i];

    EIG3(B, 0, EQM);

    IMIN = 1;
    IMAX = 3;

    if (EQM[1] > EQM[2])
      IMIN = 2;
    if (EQM[IMIN] > EQM[3])
      IMIN = 3;
    if (EQM[3] < EQM[2])
      IMAX = 2;
    if (EQM[IMAX] < EQM[1])
      IMAX = 1;

    int INUL = 6 - IMIN - IMAX;
    HELP1 = EQM[IMIN];
    HELP2 = EQM[INUL];
    HELP3 = EQM[IMAX];
    EQM[1] = HELP1;
    EQM[2] = HELP2;
    EQM[3] = HELP3;

    for (int j = 1; j <= 3; j++) {
      B[1] = B[1] - EQM[j];
      B[4] = B[4] - EQM[j];
      B[6] = B[6] - EQM[j];
      HELP1 = B[1] * B[4] - B[2] * B[2];
      if (fabs(HELP1) >= 0.001) {
        V[3][j][i] = 1.0;
        V[1][j][i] = (-B[3] * B[4] + B[2] * B[5]) / HELP1;
        V[2][j][i] = (-B[1] * B[5] + B[2] * B[3]) / HELP1;
      }
      else {
        HELP1 = B[1] * B[5] - B[2] * B[3];
        if (fabs(HELP1) >= 0.001) {
          V[2][j][i] = 1.0;
          V[1][j][i] = (-B[2] * B[5] + B[4] * B[3]) / HELP1;
          V[3][j][i] = (-B[1] * B[4] + B[2] * B[2]) / HELP1;
        }
        else {
          HELP1 = B[2] * B[5] - B[4] * B[3];
          if (fabs(HELP1) >= 0.001) {
            V[1][j][i] = 1.0;
            V[2][j][i] = (-B[1] * B[5] + B[2] * B[3]) / HELP1;
            V[3][j][i] = (-B[2] * B[2] + B[4] * B[1]) / HELP1;
          }
          else {
            V[3][j][i] = 1.0;
            V[1][j][i] = 0.0;
            V[2][j][i] = 0.0;
          }
        }
      }

      HELP1 = sqrt(
          V[1][j][i] * V[1][j][i] + V[2][j][i] * V[2][j][i]
              + V[3][j][i] * V[3][j][i]);
      if (V[3][j][i] < 0.0)
        HELP1 = -1.0 * HELP1;

      for (int k = 1; k <= 3; k++)
        V[k][j][i] = V[k][j][i] / HELP1;

      B[1] = B[1] + EQM[j];
      B[4] = B[4] + EQM[j];
      B[6] = B[6] + EQM[j];
    }
  }

  //C     Now we have EIGENVECTORS V(K,J,I), J pertaining to P,B,T,
  //C     I pertaining to F,T,D, K pertaining to 1,2,3
  for (int i = 1; i <= 3; i++) {
    for (int j = 1; j <= 3; j++) {
      HELP = amin1(V[3][j][i], 1.0);
      PLUNGE[j][i] = asin(amax1(HELP, -1.0));
      //TREND[j][i] = atan2(V[2][j][i],V[1][j][i]);
      TREND[j][i] = datan2(V[2][j][i], V[1][j][i]) * M_PI / 180.0; // Correction of ATAN2 error.
      AMP[j][i] = sqrt(
          V[1][j][i] * V[1][j][i] + V[2][j][i] * V[2][j][i]
              + V[3][j][i] * V[3][j][i]);
    }
  }

  HELP1 = 0.0;
  j = 0;
  double FaultType[4] = { 0.0, 0.0, 0.0, 0.0 };
  for (int i = 1; i <= 3; i++) {
    j = 1;
    HELP1 = PLUNGE[1][i];
    FaultType[i] = -1.0;
    if (PLUNGE[2][i] > HELP1) {
      j = 2;
      HELP1 = PLUNGE[2][i];
    }
    if (PLUNGE[3][i] > HELP1)
      j = 3;
    INFFTD[i] = INFO[j];

    if (PLUNGE[3][i] > PLUNGE[1][i]) {
      FaultType[i] = 1.0;
    }
  }

  // INFFTD contains information on fault type.
  for (int i = 1; i <= 3; i++) {
    for (int k = 1; k <= 3; k++) {
      X[k] = (V[k][3][i] - V[k][1][i]) / SQR2;
      Y[k] = (V[k][3][i] + V[k][1][i]) / SQR2;
    }

    if (X[3] < 0.0) {
      for (int k = 1; k <= 3; k++)
        X[k] = -X[k];
    }
    else if (Y[3] < 0.0) {
      for (int k = 1; k <= 3; k++)
        Y[k] = -Y[k];
    }
    STRIKE[i][1] = 0.0;
    STRIKE[i][2] = 0.0;
    X[3] = amin1(X[3], 1.0);
    Y[3] = amin1(Y[3], 1.0);
    DIP[i][1] = acos(X[3]);
    DIP[i][2] = acos(Y[3]);

    //if(DIP[i][1] > 0.01) STRIKE[i][1] = atan2(X[1],-X[2]);
    //if(DIP[i][2] > 0.01) STRIKE[i][2] = atan2(Y[1],-Y[2]);
    if (DIP[i][1] > 0.01)
      STRIKE[i][1] = datan2(X[1], -X[2]) * M_PI / 180.0; // Correction of ATAN2 error.
    if (DIP[i][2] > 0.01)
      STRIKE[i][2] = datan2(Y[1], -Y[2]) * M_PI / 180.0; // Correction of ATAN2 error.

    if (DIP[i][1] >= DIP[i][2])
      continue;

    HELP1 = DIP[i][1];
    DIP[i][1] = DIP[i][2];
    DIP[i][2] = HELP1;
    HELP1 = STRIKE[i][1];
    STRIKE[i][1] = STRIKE[i][2];
    STRIKE[i][2] = HELP1;
  }
  //   22 CONTINUE

  //---- RAKE angles calculation.
  /*
   for(int i=1; i<=3; i++)
   {
   for(int k=1; k<=2; k++)
   {
   double Value = 0.0;
   double Divisor = 0.0;

   Divisor = sin(2.0 * DIP[i][k]) * Moment0[i];
   if(Divisor == 0.0 && RM[6][i] > 0.0)
   Value = 1.0;
   else if(Divisor == 0.0 && RM[6][i] < 0.0)
   Value = -1.0;
   else Value = RM[6][i] / Divisor;
   if(Value < -1.0) Value = -1.0;
   if(Value > 1.0) Value = 1.0;
   RAKE[i][k] = asin(Value);
   }
   }
   !!! SEE LATER >>>>>
   */

  //      DO 28 I=1,3
  for (int i = 1; i <= 3; i++) {
    //      DO 29 K=1,2
    for (int k = 1; k <= 2; k++) {
      //      STRIKE(I,K)=STRIKE(I,K)*180./PI
      //      IF(STRIKE(I,K).LT.0.) STRIKE(I,K)=360.+STRIKE(I,K)
      //   29 DIP(I,K)=DIP(I,K)*180./PI
      STRIKE[i][k] = STRIKE[i][k] * 180.0 / PI;
      if (STRIKE[i][k] < 0.0)
        STRIKE[i][k] = 360.0 + STRIKE[i][k];
      DIP[i][k] = DIP[i][k] * 180.0 / PI;
      //RAKE[i][k] = RAKE[i][k]*180.0/PI; // Latter calculations >>>>>
      // Removed in version 2.4.13 of FOCI
      //if(RAKE[i][k] < -180.0) RAKE[i][k] = RAKE[i][k] + 360.0;
      //if(RAKE[i][k] > 180.0) RAKE[i][k] = RAKE[i][k] - 360.0;
    }

    // Do the rake calculations with routines from GMT.
    RAKE[i][1] = Taquart::computed_rake2(STRIKE[i][2], DIP[i][2], STRIKE[i][1],
        DIP[i][1], FaultType[i]);
    RAKE[i][2] = Taquart::computed_rake2(STRIKE[i][1], DIP[i][1], STRIKE[i][2],
        DIP[i][2], FaultType[i]);

    for (int k = 1; k <= 3; k++) {
      TREND[i][k] = TREND[i][k] * 180.0 / PI;
      if (TREND[i][k] < 0.0)
        TREND[i][k] = 360.0 + TREND[i][k];
      PLUNGE[i][k] = PLUNGE[i][k] * 180.0 / PI;
    }
  }

#ifdef USMTCORE_DEBUG
  std::cout << "Full solution:" << std::endl;
  std::cout << "--------------" << std::endl;
  std::cout << "P-axis: trend = " << TREND[1][1] << " plunge = " << PLUNGE[1][1] << std::endl;
  std::cout << "T-axis: trend = " << TREND[3][1] << " plunge = " << PLUNGE[3][1] << std::endl;
  std::cout << "B-axis: trend = " << TREND[2][1] << " plunge = " << PLUNGE[2][1] << "  " << INFFTD[1].c_str() << std::endl;
  std::cout << "           fA = " << STRIKE[1][1] << " dA = " << DIP[1][1];
  std::cout << "           fB = " << STRIKE[1][2] << " dB = " << DIP[1][2] << std::endl;
  std::cout << "Quality factor = " << ETA[1] << std::endl;
  std::cout << std::endl;

  std::cout << "Trace-null solution:" << std::endl;
  std::cout << "--------------------" << std::endl;
  std::cout << "P-axis: trend = " << TREND[1][2] << " plunge = " << PLUNGE[1][2] << std::endl;
  std::cout << "T-axis: trend = " << TREND[3][2] << " plunge = " << PLUNGE[3][2] << std::endl;
  std::cout << "B-axis: trend = " << TREND[2][2] << " plunge = " << PLUNGE[2][2] << "  " << INFFTD[2].c_str() << std::endl;
  std::cout << "           fA = " << STRIKE[2][1] << " dA = " << DIP[2][1];
  std::cout << "           fB = " << STRIKE[2][2] << " dB = " << DIP[2][2] << std::endl;
  std::cout << "Quality factor = " << ETA[2] << std::endl;
  std::cout << std::endl;

  std::cout << "Double-couple solution:" << std::endl;
  std::cout << "-----------------------" << std::endl;
  std::cout << "P-axis: trend = " << TREND[1][3] << " plunge = " << PLUNGE[1][3] << std::endl;
  std::cout << "T-axis: trend = " << TREND[3][3] << " plunge = " << PLUNGE[3][3] << std::endl;
  std::cout << "B-axis: trend = " << TREND[2][3] << " plunge = " << PLUNGE[2][3] << "  " << INFFTD[3].c_str() << std::endl;
  std::cout << "           fA = " << STRIKE[3][1] << " dA = " << DIP[3][1];
  std::cout << "           fB = " << STRIKE[3][2] << " dB = " << DIP[3][2] << std::endl;
  std::cout << "Quality factor = " << ETA[3] << std::endl;
  std::cout << std::endl;
#endif

  for (int i = 1; i <= 3; i++) {
    Solution[i].FIA = STRIKE[i][1];
    Solution[i].DLA = DIP[i][1];
    Solution[i].RAKEA = RAKE[i][1];
    Solution[i].FIB = STRIKE[i][2];
    Solution[i].DLB = DIP[i][2];
    Solution[i].RAKEB = RAKE[i][2];
    Solution[i].PXTR = TREND[1][i];
    Solution[i].PXPL = PLUNGE[1][i];
    Solution[i].PXAM = AMP[1][i];
    Solution[i].TXTR = TREND[3][i];
    Solution[i].TXPL = PLUNGE[3][i];
    Solution[i].TXAM = AMP[3][i];
    Solution[i].BXTR = TREND[2][i];
    Solution[i].BXPL = PLUNGE[2][i];
    Solution[i].BXAM = AMP[2][i];
    Solution[i].QI = ETA[i];
    Solution[i].Type = INFFTD[i];
  }
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::MOM2(bool REALLY, int QualityType) {
  //      SUBROUTINE MOM2(REALLY)
  //      CHARACTER PS(80),TITLE*40
  //      REAL U(80),ARR(80),AZM(80),TKF(80),A(80,6),ATA(6,6),
  //     $ATAINV(6,6),B(6),EQM(3),AA(80,6),Z1(9,9),Z2(9,9),H(80,5),
  //     $IW(80),PA(3),BB(6),RM0(3),RMT(3),PCLVD(2),PDBCP(2),LLA(3),HA(2)
  //      INTEGER RO(80),VEL(80),R(80)
  //      COMMON/MDATA/ PS,U,ARR,AZM,TKF,RO,VEL,R,TITLE,N,TROZ
  //      COMMON/GAGAGA/ GA(80,3)
  //      COMMON/MOMNT/ RM(6,3)
  //      COMMON/RESTEX/ RESULT
  //      CHARACTER*56 RESULT(34)
  //      DOUBLE PRECISION COV(6,6,3),SAI22
  //      COMMON/VCOVAR/ COV
  //      LOGICAL REALLY

  //      PI=4.*ATAN(1.)
  double PI = 4.0 * atan(1.0);
  int IW[FOCIMT_MAXCHANNEL + 1];
  double PA[3 + 1];
  Zero(&PA[0], 4);
  double ATA[6 + 1][6 + 1];
  Zero(&ATA[0][0], 49);
  double ATAINV[6 + 1][6 + 1];
  Zero(&ATAINV[0][0], 49);
  double Z1[9 + 1][9 + 1];
  Zero(&Z1[0][0], 100);
  double Z2[9 + 1][9 + 1];
  Zero(&Z2[0][0], 100);
  double BB[6 + 1];
  Zero(&BB[0], 7);
  double B[6 + 1];
  Zero(&B[0], 7);
  double EQM[3 + 1];
  Zero(EQM, 4);
  double EQQ1 = 0.0, EQQ2 = 0.0, EQQ3 = 0.0;
  double HELP1 = 0.0, HELP2 = 0.0, HELP3 = 0.0;
  double EU = 0.0, EC = 0.0;
  double RM0[3 + 1];
  Zero(RM0, 4);
  double RMT[3 + 1];
  Zero(RMT, 4);
  double RMERR[3 + 1];
  Zero(RMERR, 4);
  double EPS = 0.0;
  double SAI22 = 0.0;
  double SIG = 0.0;
  double AA[FOCIMT_MAXCHANNEL + 1][6 + 1];
  Zero(&AA[0][0], (FOCIMT_MAXCHANNEL + 1) * 7);
  double DUM = 0.0;
  double H[FOCIMT_MAXCHANNEL + 1][5 + 1];
  Zero(&H[0][0], (FOCIMT_MAXCHANNEL + 1) * 6);
  double RMX = 0.0, RMY = 0.0, RMZ = 0.0;
  double RMAG = 0.0;
  double PEXPL[4], PCLVD[3 + 1], PDBCP[3 + 1];
  double PEXPL_VAC[4], PCLVD_VAC[3 + 1], PDBCP_VAC[3 + 1];
  double ALF = 0.0;
  double MAGN[4];
  double HELP = 0.0;
  double LLA[4];
  Zero(LLA, 4);
  double HA[4];
  Zero(HA, 4);

  //      DO 3 I=1,N
  for (int i = 1; i <= N; i++) {
    //      IW(I)=0
    //      IF((PS(I).EQ.'S').OR.(PS(I).EQ.'s')) IW(I)=1
    //      IF((PS(I).EQ.'H').OR.(PS(I).EQ.'h')) IW(I)=2
    IW[i] = 0;
    //if(PS[i] == 'S' || PS[i] == 's') IW[i] = 1;
    //if(PS[i] == 'H' || PS[i] == 'h') IW[i] = 2;

    //      ALF=FLOAT(VEL(I))
    //      HELP=4.*PI*FLOAT(RO(I))*ALF*ALF*ALF*FLOAT(R(I))*TROZ*1.E-12
    ALF = VEL[i];

    /* DONE  5 -c2.4.14 : Problem z kalibracjï¿½ (USMTCORE) */
    HELP = 4.0 * PI
        * double(RO[i]) * ALF * ALF * ALF * double(R[i]) * USMT_DOWNSCALE;

    //      IF(IW(I).NE.0) GO TO 5
    if (IW[i] == 0) {
      //C     For P:
      //      A(I,1)=GA(I,1)*GA(I,1)/HELP
      //      A(I,2)=2.*GA(I,1)*GA(I,2)/HELP
      //      A(I,3)=2.*GA(I,1)*GA(I,3)/HELP
      //      A(I,4)=GA(I,2)*GA(I,2)/HELP
      //      A(I,5)=2.*GA(I,2)*GA(I,3)/HELP
      //      A(I,6)=GA(I,3)*GA(I,3)/HELP
      //      GO TO 3
      A[i][1] = GA[i][1] * GA[i][1] / HELP;
      A[i][2] = 2.0 * GA[i][1] * GA[i][2] / HELP;
      A[i][3] = 2.0 * GA[i][1] * GA[i][3] / HELP;
      A[i][4] = GA[i][2] * GA[i][2] / HELP;
      A[i][5] = 2. * GA[i][2] * GA[i][3] / HELP;
      A[i][6] = GA[i][3] * GA[i][3] / HELP;
    }
    /* Code for SV and SH is switched off by default. */
    /*
     else
     {
     //C     For SV:
     //    5 SVANG=REAL(ARR(I))*PI/180.
     //      PA(3)=-SIN(SVANG)
     //      SKAL=-COS(SVANG)/SQRT(GA(I,1)*GA(I,1)+GA(I,2)*GA(I,2))
     //      PA(1)=GA(I,1)*SKAL
     //      PA(2)=GA(I,2)*SKAL
     SVANG = double(ARR[i]) * PI / 180.0;
     PA[3] = -sin(SVANG);
     SKAL = -cos(SVANG) / sqrt(GA[i][1] * GA[i][1] + GA[i][2] * GA[i][2]);
     PA[1] = GA[i][1] * SKAL;
     PA[2] = GA[i][2] * SKAL;

     //      IF(IW(I).EQ.2) GO TO 6
     if(IW[i] != 2)
     {
     //      A(I,1)=GA(I,1)*PA(1)/HELP
     //      A(I,2)=(GA(I,1)*PA(2)+GA(I,2)*PA(1))/HELP
     //      A(I,3)=(GA(I,1)*PA(3)+GA(I,3)*PA(1))/HELP
     //      A(I,4)=GA(I,2)*PA(2)/HELP
     //      A(I,5)=(GA(I,2)*PA(3)+GA(I,3)*PA(2))/HELP
     //      A(I,6)=GA(I,3)*PA(3)/HELP
     //      GO TO 3
     A[i][1]=GA[i][1]*PA[1]/HELP;
     A[i][2]=(GA[i][1]*PA[2]+GA[i][2]*PA[1])/HELP;
     A[i][3]=(GA[i][1]*PA[3]+GA[i][3]*PA[1])/HELP;
     A[i][4]=GA[i][2]*PA[2]/HELP;
     A[i][5]=(GA[i][2]*PA[3]+GA[i][3]*PA[2])/HELP;
     A[i][6]=GA[i][3]*PA[3]/HELP;
     }
     else
     {
     //C     For SH:
     //    6 LLA(3)=-COS(SVANG)
     //      SKAL=SIN(SVANG)/SQRT(GA(I,1)*GA(I,1)+GA(I,2)*GA(I,2))
     //      LLA(1)=GA(I,1)*SKAL
     //      LLA(2)=GA(I,2)*SKAL
     //      HA(1)=LLA(2)*PA(3)-LLA(3)*PA(2)
     //      HA(2)=-LLA(1)*PA(3)+LLA(3)*PA(1)
     //      A(I,1)=GA(I,1)*HA(1)/HELP+LLA(3)*GA(I,1)*PA(1)/HELP
     //      A(I,2)=(GA(I,1)*HA(2)+GA(I,2)*HA(1))/HELP
     //     $+LLA(3)*(GA(I,1)*PA(2)+GA(I,2)*PA(1))/HELP
     //      A(I,3)=GA(I,3)*HA(1)/HELP+LLA(3)*(GA(I,1)*PA(3)+GA(I,3)*PA(1))
     //     $/HELP
     //      A(I,4)=GA(I,2)*HA(2)/HELP+LLA(3)*GA(I,2)*PA(2)/HELP
     //      A(I,5)=GA(I,3)*HA(2)/HELP+LLA(3)*(GA(I,2)*PA(3)+GA(I,3)*PA(2))
     //     $/HELP
     //      A(I,6)=+LLA(3)*GA(I,3)*PA(3)/HELP

     LLA[3]=-cos(SVANG);
     SKAL = sin(SVANG)/sqrt(GA[i][1]*GA[i][1]+GA[i][2]*GA[i][2]);
     LLA[1]=GA[i][1]*SKAL;
     LLA[2]=GA[i][2]*SKAL;
     HA[1]=LLA[2]*PA[3]-LLA[3]*PA[2];
     HA[2]=-LLA[1]*PA[3]+LLA[3]*PA[1];
     A[i][1]=GA[i][1]*HA[1]/HELP+LLA[3]*GA[i][1]*PA[1]/HELP;
     A[i][2]=(GA[i][1]*HA[2]+GA[i][2]*HA[1])/HELP+LLA[3]*(GA[i][1]*PA[2]+GA[i][2]*PA[1])/HELP;
     A[i][3]=GA[i][3]*HA[1]/HELP+LLA[3]*(GA[i][1]*PA[3]+GA[i][3]*PA[1])/HELP;
     A[i][4]=GA[i][2]*HA[2]/HELP+LLA[3]*GA[i][2]*PA[2]/HELP;
     A[i][5]=GA[i][3]*HA[2]/HELP+LLA[3]*(GA[i][2]*PA[3]+GA[i][3]*PA[2])/HELP;
     A[i][6]=+LLA[3]*GA[i][3]*PA[3]/HELP;
     }
     }
     */
  }
  //    3 CONTINUE

  // Full moment tensor.
  if (REALLY) {
    for (int i = 1; i <= 6; i++) {
      for (int j = 1; j <= 6; j++) {
        ATA[i][j] = 0.0;
        for (int k = 1; k <= N; k++)
          ATA[i][j] = ATA[i][j] + A[k][j] * A[k][i];
      }
    }

    for (int i = 1; i <= 6; i++) {
      for (int j = 1; j <= 6; j++) {
        Z1[i][j] = ATA[i][j];
      }
    }

    INVMAT(Z1, Z2, 6);

    for (int i = 1; i <= 6; i++) {
      for (int j = 1; j <= 6; j++) {
        ATAINV[i][j] = Z2[i][j];
      }
    }

    for (int i = 1; i <= 6; i++) {
      B[i] = 0.0;
      for (int j = 1; j <= N; j++) {
        B[i] = B[i] + A[j][i] * U[j] * USMT_UPSCALE;
      }
    }

    for (int i = 1; i <= 6; i++) {
      RM[i][1] = 0.0;
      for (int j = 1; j <= 6; j++) {
        RM[i][1] = RM[i][1] + ATAINV[i][j] * B[j];
      }
    }

    // Find scalar seismic moment.
    for (int i = 1; i <= 6; i++)
      BB[i] = RM[i][1];

    EIG3(BB, 0, EQM);

    EQQ1 = EQM[1];
    EQQ2 = EQM[2];
    EQQ3 = EQM[3];
    EQM[1] = fabs(EQM[1]) * USMT_DOWNSCALE;
    EQM[2] = fabs(EQM[2]) * USMT_DOWNSCALE;
    EQM[3] = fabs(EQM[3]) * USMT_DOWNSCALE;
    HELP1 = fabs(EQM[1] - EQM[2]);
    HELP2 = fabs(EQM[1] - EQM[3]);
    HELP3 = fabs(EQM[2] - EQM[3]);
    EU = sqrt(0.5 * (EQM[1] * EQM[1] + EQM[2] * EQM[2] + EQM[3] * EQM[3]));
    EC = amax1(HELP1, HELP2);
    EC = amax1(EC, HELP3);
    RMT[1] = amax1(EC, EU) * USMT_UPSCALE;
    RM0[1] = amin1(EC, EU) * USMT_UPSCALE;

    // Covariance calculation.
    for (int i = 1; i <= N; i++) {
      EPS = U[i];
      //---- Calculate theoretical displacement.
      UTH[i][1] = 0.0f;
      for (int j = 1; j <= 6; j++)
        UTH[i][1] += A[i][j] * RM[j][1] * USMT_DOWNSCALE;
      //---- Calculate theoretical displacement.
      for (int j = 1; j <= 6; j++)
        EPS = EPS - A[i][j] * RM[j][1] * USMT_DOWNSCALE;
      SAI22 = 0.0;
      for (int j = 1; j <= 6; j++)
        SAI22 = SAI22 + A[i][j] * A[i][j];
      double SAI2 = double(SAI22);
      for (int j = 1; j <= 6; j++)
        AA[i][j] = EPS * (A[i][j] / SAI2) * USMT_UPSCALE;
      for (int j = 1; j <= 6; j++)
        AA[i][j] = AA[i][j] + RM[j][1];
    }

#ifdef USMTCORE_DEBUG
    std::cout << std::endl;
#endif
    for (int i = 1; i <= 6; i++) {
      for (int j = 1; j <= 6; j++) {
        COV[i][j][1] = 0.0;
        for (int k = 1; k <= N; k++)
          COV[i][j][1] = COV[i][j][1]
              + (AA[k][i] - RM[i][1]) * (AA[k][j] - RM[j][1]);
        COV[i][j][1] = COV[i][j][1] / double((N - 6) * (N - 6));
#ifdef USMTCORE_DEBUG
        std::cout << FormatFloat("0.000e+00",COV[i][j][1]).c_str() << " ";
#endif
      }
#ifdef USMTCORE_DEBUG
      std::cout << std::endl;
#endif
    }
#ifdef USMTCORE_DEBUG
    std::cout << std::endl;
#endif

    SIG = 0.0;
    for (int i = 1; i <= 6; i++) {
      double SIGH = sqrt(COV[i][i][1]);
      if (SIG < SIGH)
        SIG = SIGH;
    }
    RMERR[1] = SIG;

#ifdef USMTCORE_DEBUG
    std::cout << "L2 Tensor:" << std::endl << std::endl;
    std::cout << "Full solution:" << std::endl;
    std::cout << RM[1][1] << '\t' << RM[2][1] << '\t' << RM[3][1] << std::endl;
    std::cout << RM[2][1] << '\t' << RM[4][1] << '\t' << RM[5][1] << std::endl;
    std::cout << RM[3][1] << '\t' << RM[5][1] << '\t' << RM[6][1] << std::endl;
    std::cout << "T0 = " << TROZ << " M0 = " << RM0[1] << " MT = " << RMT[1] << " ERR = " << SIG;
    std::cout << std::endl;
#endif

    // Full moment tensor solution, norm L2.
    Solution[1].E[0] = EQQ1;
    Solution[1].E[1] = EQQ2;
    Solution[1].E[2] = EQQ3;
    EIGGEN(EQQ1, EQQ2, EQQ3, PEXPL[1], PCLVD[1], PDBCP[1], PEXPL_VAC[1],
        PCLVD_VAC[1], PDBCP_VAC[1]);
    RMAG = mw(RM0[1]);
    MAGN[1] = RMAG;

#ifdef USMTCORE_DEBUG
    std::cout << " EXPL = " << PEXPL << " PCLVD = " << PCLVD[1];
    std::cout << " PDBCP = " << PDBCP[1] << " Mw = " << RMAG << std::endl;
    std::cout << std::endl;
#endif
  } // if REALLY

  for (int i = 1; i <= N; i++) {
    H[i][1] = A[i][1] - A[i][6];
    H[i][2] = A[i][2];
    H[i][3] = A[i][3];
    H[i][4] = A[i][4] - A[i][6];
    H[i][5] = A[i][5];
  }

  // Solve equation HM=U for M:
  for (int i = 1; i <= 5; i++) {
    for (int j = 1; j <= 5; j++) {
      ATA[i][j] = 0.0;
      for (int k = 1; k <= N; k++)
        ATA[i][j] = ATA[i][j] + H[k][j] * H[k][i];
    }
  }

  for (int i = 1; i <= 5; i++) {
    for (int j = 1; j <= 5; j++) {
      Z1[i][j] = ATA[i][j];
    }
  }

  INVMAT(Z1, Z2, 5);

  for (int i = 1; i <= 5; i++) {
    for (int j = 1; j <= 5; j++) {
      ATAINV[i][j] = Z2[i][j];
    }
  }

  for (int i = 1; i <= 5; i++) {
    B[i] = 0.0;
    for (int j = 1; j <= N; j++) {
      B[i] = B[i] + H[j][i] * U[j] * USMT_UPSCALE;
    }
  }

  for (int i = 1; i <= 5; i++) {
    RM[i][2] = 0.0;
    for (int j = 1; j <= 5; j++) {
      RM[i][2] = RM[i][2] + ATAINV[i][j] * B[j];
    }
  }

  RM[6][2] = -RM[1][2] - RM[4][2];

  for (int i = 1; i <= 6; i++)
    BB[i] = RM[i][2];

  EIG3(BB, 0, EQM);

  EQQ1 = EQM[1];
  EQQ2 = EQM[2];
  EQQ3 = EQM[3];
  EQM[1] = fabs(EQM[1]) * USMT_DOWNSCALE;
  EQM[2] = fabs(EQM[2]) * USMT_DOWNSCALE;
  EQM[3] = fabs(EQM[3]) * USMT_DOWNSCALE;
  HELP1 = fabs(EQM[1] - EQM[2]);
  HELP2 = fabs(EQM[1] - EQM[3]);
  HELP3 = fabs(EQM[2] - EQM[3]);
  EU = sqrt(0.5 * (EQM[1] * EQM[1] + EQM[2] * EQM[2] + EQM[3] * EQM[3]));
  EC = amax1(HELP1, HELP2);
  EC = amax1(EC, HELP3);
  RMT[2] = amax1(EC, EU) * USMT_UPSCALE;
  RM0[2] = amin1(EC, EU) * USMT_UPSCALE;

  for (int i = 1; i <= N; i++) {
    EPS = U[i];
    //---- Calculate theoretical displacement.
    UTH[i][2] = 0.0f;
    for (int j = 1; j <= 6; j++)
      UTH[i][2] += A[i][j] * RM[j][2] * USMT_DOWNSCALE;
    //---- Calculate theoretical displacement.
    for (int j = 1; j <= 6; j++)
      EPS = EPS - A[i][j] * RM[j][2] * USMT_DOWNSCALE;
    SAI22 = 0.0;
    for (int j = 1; j <= 6; j++)
      SAI22 = SAI22 + A[i][j] * A[i][j];
    double SAI2 = double(SAI22);
    for (int j = 1; j <= 6; j++)
      AA[i][j] = EPS * (A[i][j] / SAI2) * USMT_UPSCALE;
    for (int j = 1; j <= 6; j++)
      AA[i][j] = AA[i][j] + RM[j][2];
  }

#ifdef USMTCORE_DEBUG
  std::cout << std::endl;
#endif
  for (int i = 1; i <= 6; i++) {
    for (int j = 1; j <= 6; j++) {
      COV[i][j][2] = 0.0;
      for (int k = 1; k <= N; k++)
        COV[i][j][2] = COV[i][j][2]
            + (AA[k][i] - RM[i][2]) * (AA[k][j] - RM[j][2]);
      COV[i][j][2] = COV[i][j][2] / double((N - 6) * (N - 6));
#ifdef USMTCORE_DEBUG
      std::cout << FormatFloat("0.000e+00",COV[i][j][2]).c_str() << " ";
#endif
    }
#ifdef USMTCORE_DEBUG
    std::cout << std::endl;
#endif
  }
#ifdef USMTCORE_DEBUG
  std::cout << std::endl;
#endif
  //      IF(.NOT.REALLY) RETURN
  if (!REALLY)
    return;

  SIG = 0.0;
  for (int i = 1; i <= 6; i++) {
    double SIGH = sqrt(COV[i][i][2]);
    if (SIG < SIGH)
      SIG = SIGH;
  }
  RMERR[2] = SIG;

#ifdef USMTCORE_DEBUG
  std::cout << "Trace-null solution:" << std::endl;
  std::cout << RM[1][2] << '\t' << RM[2][2] << '\t' << RM[3][2] << std::endl;
  std::cout << RM[2][2] << '\t' << RM[4][2] << '\t' << RM[5][2] << std::endl;
  std::cout << RM[3][2] << '\t' << RM[5][2] << '\t' << RM[6][2] << std::endl;
  std::cout << "T0 = " << TROZ << " M0 = " << RM0[2] << " MT = " << RMT[2] << " ERR = " << SIG;
  std::cout << std::endl;
#endif

  // Trace-null moment tensor solution, norm L2.
  Solution[2].E[0] = EQQ1;
  Solution[2].E[1] = EQQ2;
  Solution[2].E[2] = EQQ3;
  EIGGEN(EQQ1, EQQ2, EQQ3, DUM, PCLVD[2], PDBCP[2], DUM, PCLVD_VAC[2],
      PDBCP_VAC[2]);
  RMAG = mw(RM0[2]);
  MAGN[2] = RMAG;

#ifdef USMTCORE_DEBUG
  std::cout << " PCLVD = " << PCLVD[2];
  std::cout << " PDBCP = " << PDBCP[2] << " Mw = " << RMAG << std::endl;
  std::cout << std::endl;
#endif
  PEXPL[2] = 0.0;

  //==== DOUBLE COUPLE SOLUTION ==============================================

  FIJGEN();

  for (int i = 1; i <= 6; i++)
    B[i] = RM[i][2];

  EIG3(B, 1, EQM);

  RMX = EQM[1];
  if (fabs(EQM[2]) < fabs(RMX))
    RMX = EQM[2];
  if (fabs(EQM[3]) < fabs(RMX))
    RMX = EQM[3];

  RMY = EQM[3];
  if (fabs(EQM[1]) > fabs(RMY))
    RMY = EQM[1];
  if (fabs(EQM[2]) > fabs(RMY))
    RMY = EQM[2];

  if (EQM[1] != RMX && EQM[1] != RMY)
    RMZ = EQM[1];
  if (EQM[2] != RMX && EQM[2] != RMY)
    RMZ = EQM[2];
  if (EQM[3] != RMX && EQM[3] != RMY)
    RMZ = EQM[3];

  BETTER(RMY, RMZ, RM0[3], RMT[3], ICOND);

  for (int i = 1; i <= 6; i++)
    B[i] = RM[i][3];

  EIG3(B, 1, EQM);

  EQQ1 = EQM[1];
  EQQ2 = EQM[2];
  EQQ3 = EQM[3];

  for (int i = 1; i <= N; i++) {
    EPS = U[i];
    //---- Calculate theoretical displacement.
    UTH[i][3] = 0.0f;
    for (int j = 1; j <= 6; j++)
      UTH[i][3] += A[i][j] * RM[j][3] * USMT_DOWNSCALE;
    //---- Calculate theoretical displacement.
    for (int j = 1; j <= 6; j++)
      EPS = EPS - A[i][j] * RM[j][3] * USMT_DOWNSCALE;
    SAI22 = 0.0;
    for (int j = 1; j <= 6; j++)
      SAI22 = SAI22 + A[i][j] * A[i][j];
    double SAI2 = double(SAI22);
    for (int j = 1; j <= 6; j++)
      AA[i][j] = EPS * (A[i][j] / SAI2) * USMT_UPSCALE;
    for (int j = 1; j <= 6; j++)
      AA[i][j] = AA[i][j] + RM[j][3];
  }

#ifdef USMTCORE_DEBUG
  std::cout << std::endl;
#endif
  for (int i = 1; i <= 6; i++) {
    for (int j = 1; j <= 6; j++) {
      COV[i][j][3] = 0.0;
      for (int k = 1; k <= N; k++)
        COV[i][j][3] = COV[i][j][3]
            + (AA[k][i] - RM[i][3]) * (AA[k][j] - RM[j][3]);
      COV[i][j][3] = COV[i][j][3] / double((N - 6) * (N - 6));
#ifdef USMTCORE_DEBUG
      std::cout << FormatFloat("0.000e+00",COV[i][j][3]).c_str() << " ";
#endif
    }
#ifdef USMTCORE_DEBUG
    std::cout << std::endl;
#endif
  }
#ifdef USMTCORE_DEBUG
  std::cout << std::endl;
#endif
  SIG = 0.0;
  for (int i = 1; i <= 6; i++) {
    double SIGH = sqrt(COV[i][i][3]);
    if (SIG < SIGH)
      SIG = SIGH;
  }
  RMERR[3] = SIG;

#ifdef USMTCORE_DEBUG
  std::cout << "Double-couple solution:" << std::endl;
  std::cout << RM[1][3] << '\t' << RM[2][3] << '\t' << RM[3][3] << std::endl;
  std::cout << RM[2][3] << '\t' << RM[4][3] << '\t' << RM[5][3] << std::endl;
  std::cout << RM[3][3] << '\t' << RM[5][3] << '\t' << RM[6][3] << std::endl;
  std::cout << "T0 = " << TROZ << " M0 = " << RM0[3] << " MT = " << RMT[3] << " ERR = " << SIG;
  std::cout << std::endl;
#endif

  // Double-couple solution, norm L2.
  Solution[3].E[0] = EQQ1;
  Solution[3].E[1] = EQQ2;
  Solution[3].E[2] = EQQ3;

  RMAG = mw(RM0[3]);
  MAGN[3] = RMAG;
  PDBCP[3] = 100.0;
  PCLVD[3] = 0.0;
  PEXPL[3] = 0.0;

  PDBCP_VAC[3] = 100.0;
  PCLVD_VAC[3] = 0.0;
  PEXPL_VAC[3] = 0.0;

#ifdef USMTCORE_DEBUG
  std::cout << " PDBCP = 100% Mw = " << RMAG << std::endl;
  std::cout << std::endl;
#endif

  // Transfer data to output structure
  for (int i = 1; i <= N; i++) {
    Solution[1].U_n = N;
    Solution[2].U_n = N;
    Solution[3].U_n = N;
    Solution[1].U_th[i - 1] = UTH[i][1];
    Solution[2].U_th[i - 1] = UTH[i][2];
    Solution[3].U_th[i - 1] = UTH[i][3];
    Solution[1].U_measured[i - 1] = U[i];
    Solution[2].U_measured[i - 1] = U[i];
    Solution[3].U_measured[i - 1] = U[i];
    Solution[1].Station[i - 1] = Station[i];
    Solution[2].Station[i - 1] = Station[i];
    Solution[3].Station[i - 1] = Station[i];
  }

  //std::ofstream file("file.txt",std::ofstream::out | std::ofstream::app);
  for (int q = 1; q <= 3; q++) {
    double up = 0.0;
    double down = 0.0;
    for (int i = 1; i <= N; i++) {
      //file << UTH[i][q] << " " << U[i] << std::endl;
      up += ((UTH[i][q] - U[i]) * (UTH[i][q] - U[i]));
      down += (U[i] * U[i]);
    }
    if (down == 0.0)
      Solution[q].UERR = 0.0;
    else
      Solution[q].UERR = sqrt(up / down);
  }
  //file.close();

  for (int i = 1; i <= 3; i++) {
    int z = 0;
    int v[] = { 1, 2, 3, 2, 4, 5, 3, 5, 6 };
    for (int m = 1; m <= 3; m++)
      for (int n = 1; n <= 3; n++) {
        Solution[i].M[m][n] = RM[v[z]][i];
        z++;
      }
    Solution[i].T0 = TROZ;
    Solution[i].M0 = RM0[i];
    Solution[i].MT = RMT[i];
    Solution[i].ERR = RMERR[i];
    Solution[i].EXPL = PEXPL[i];
    Solution[i].CLVD = PCLVD[i];
    Solution[i].DBCP = PDBCP[i];
    Solution[i].EXPL_VAC = PEXPL_VAC[i];
    Solution[i].CLVD_VAC = PCLVD_VAC[i];
    Solution[i].DBCP_VAC = PDBCP_VAC[i];
    Solution[i].MAGN = MAGN[i];

    for (int m = 1; m <= 6; m++)
      for (int n = 1; n <= 6; n++)
        Solution[i].Covariance[m][n] = COV[m][n][i];
  }

  ICOND = QualityType;
  XTRINF(ICOND, 2, RM0, RMERR);
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::INVMAT(double A[][10], double B[][10], int NP) {
  double Y[10][10];
  Zero(&Y[0][0], 100);
  double ALU[10][10];
  Zero(&ALU[0][0], 100);
  int INDX[10];
  for (int i = 0; i < 10; i++)
    INDX[i] = 0;
  double D = 0;
  for (int i = 1; i <= NP; i++) {
    for (int j = 1; j <= NP; j++) {
      Y[i][j] = 0.0;
    }
    Y[i][i] = 1.0;
  }
  LUDCMP(A, ALU, INDX, D, NP);
  for (int j = 1; j <= NP; j++) {
    LUBKSB2(ALU, INDX, Y, B, NP, j);
  }
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::LUBKSB2(double A[][10], int INDX[], double C[][10],
    double B[][10], int &NP, int jj) {

  for (int i = 1; i <= NP; i++)
    B[i][jj] = C[i][jj];
  int II = 0;
  for (int i = 1; i <= NP; i++) {
    int LL = INDX[i];
    double SUM = B[LL][jj];
    B[LL][jj] = B[i][jj];
    if (II != 0) {
      for (int j = II; j <= i - 1; j++)
        SUM = SUM - A[i][j] * B[j][jj];
    }
    else if (SUM != 0.0) {
      II = i;
    }
    B[i][jj] = SUM;
  }
  for (int i = NP; i >= 1; i--) {
    double SUM = B[i][jj];
    if (i < NP) {
      for (int j = i + 1; j <= NP; j++)
        SUM = SUM - A[i][j] * B[j][jj];
    }
    B[i][jj] = SUM / A[i][i];
  }
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::LUDCMP(double B[][10], double A[][10], int INDX[],
    double &D, int &NP) {
  //      SUBROUTINE LUDCMP(B,A,INDX,D,NP)
  //C     Given a matrix A , this routine replaces it by LU decomposition of
  //C     a rowwise permutation of itself. B is input, copied into A. INDX is an
  //C     output vector which records row permutation. D is output as +-1 depending
  //C     on the odd or even number of row interchanges.
  //      DIMENSION A(9,9),B(9,9),INDX(9),VV(100)
  //      DATA TINY/1.E-20/
  double TINY = 1.0e-20;
  double VV[100];
  Zero(&VV[0], 100);
  double AAMAX = 0.0;
  int IMAX = 0;
  double SUM = 0.0;
  double DUM = 0.0;

  for (int i = 1; i <= NP; i++)
    for (int j = 1; j <= NP; j++)
      A[i][j] = B[i][j];

  D = 1.0;

  for (int i = 1; i <= NP; i++) {
    AAMAX = 0.0;
    for (int j = 1; j <= NP; j++) {
      if (fabs(A[i][j]) > AAMAX)
        AAMAX = fabs(A[i][j]);
    }
    if (AAMAX == 0.0)
      AAMAX = TINY;
    VV[i] = 1.0 / AAMAX;
  }

  for (int j = 1; j <= NP; j++) {
    for (int i = 1; i <= j - 1; i++) {
      SUM = A[i][j];
      for (int k = 1; k <= i - 1; k++) {
        SUM = SUM - A[i][k] * A[k][j];
      }
      A[i][j] = SUM;
    }
    AAMAX = 0.0;
    IMAX = 0;

    for (int i = j; i <= NP; i++) {
      SUM = A[i][j];
      for (int k = 1; k <= j - 1; k++) {
        SUM = SUM - A[i][k] * A[k][j];
      }
      A[i][j] = SUM;
      DUM = VV[i] * fabs(SUM);
      if (DUM >= AAMAX) {
        IMAX = i;
        AAMAX = DUM;
      }
    }
    if (j != IMAX) {
      for (int k = 1; k <= NP; k++) {
        DUM = A[IMAX][k];
        A[IMAX][k] = A[j][k];
        A[j][k] = DUM;
      }
      D = -D;
      VV[IMAX] = VV[j];
    }
    INDX[j] = IMAX;
    if (A[j][j] == 0.0)
      A[j][j] = TINY;
    if (j != NP) {
      DUM = 1.0 / A[j][j];
      for (int i = j + 1; i <= NP; i++) {
        A[i][j] = A[i][j] * DUM;
      }
    }
  }
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::FIJGEN(void) {
  for (int i = 1; i <= N; i++) {
    double THE = acos(GA[i][3]);
    //double PHI = atan2(GA[i][1],GA[i][2);
    double PHI = datan2(GA[i][1], GA[i][2]) * M_PI / 180.0; // Correction in v3.1.19 of FOCI due to ATAN2 error.
    FIJ[1][1][i] = pow(sin(THE) * sin(PHI), 2.0);
    FIJ[1][2][i] = 0.5 * sin(THE) * sin(THE) * sin(2.0 * PHI);
    FIJ[1][3][i] = -0.5 * sin(2.0 * THE) * sin(PHI);
    FIJ[2][2][i] = pow(sin(THE) * cos(PHI), 2.0);
    FIJ[2][3][i] = -0.5 * sin(2.0 * THE) * cos(PHI);
    FIJ[3][3][i] = cos(PHI) * cos(PHI);
    FIJ[2][1][i] = FIJ[1][2][i];
    FIJ[3][1][i] = FIJ[1][3][i];
    FIJ[3][2][i] = FIJ[2][3][i];
  }
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::Zero(double * Address, int C) {
  for (int i = 0; i < C; i++)
    *(Address + i) = 0.0;
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::BETTER(double &RMY, double &RMZ, double &RM0,
    double &RMT, int &ICOND) {
  //      SUBROUTINE BETTER(RMY,RMZ,RM0,RMT,ICOND)
  //      CHARACTER PS(80),TITLE*40
  //      REAL U(80),ARR(80),AZM(80),TKF(80),vn(3),ve(3),Z1(9,9),
  //     $Z2(9,9),DD(6),EQM(3)
  //      INTEGER RO(80),VEL(80),R(80)
  //      COMMON/MDATA/ PS,U,ARR,AZM,TKF,RO,VEL,R,TITLE,N,TROZ
  //      COMMON/GAGAGA/ GA(80,3)
  //      COMMON/MOMNT/ RM(6,3)
  //      COMMON/AUXIL/ FIJ(3,3,80)
  //      COMMON/PRIPAR/ IWUL,ILAS,ISTA,ISHD,IDCSHW,IAXS,IUND
  //      DOUBLE PRECISION U0,U1,C(6,80),BB(8,8),BBINV(8,8),DE(3),EPS,
  //     $DN(3),DU(80),CTDU(8),X(8),dhelp1,dhelp2,sume,sumn,AM0(80)
  double VN[3 + 1];
  Zero(VN, 4);
  double VE[3 + 1];
  Zero(VE, 4);
  double AM0[FOCIMT_MAXCHANNEL + 1];
  Zero(AM0, FOCIMT_MAXCHANNEL + 1);
  double DD[6 + 1];
  Zero(DD, 7);
  double EQM[3 + 1];
  Zero(EQM, 4);
  double EC = 0.0;
  double C[6 + 1][FOCIMT_MAXCHANNEL + 1];
  Zero(&C[0][0], 7 * (FOCIMT_MAXCHANNEL + 1));
  double BB[8 + 1][8 + 1];
  Zero(&BB[0][0], 81);
  double BBINV[8 + 1][8 + 1];
  Zero(&BBINV[0][0], 81);
  double Z1[9 + 1][9 + 1];
  Zero(&Z1[0][0], 100);
  double Z2[9 + 1][9 + 1];
  Zero(&Z2[0][0], 100);
  double DE[3 + 1];
  Zero(DE, 4);
  double DU[FOCIMT_MAXCHANNEL + 1];
  Zero(DU, FOCIMT_MAXCHANNEL + 1);
  double DN[3 + 1];
  Zero(DN, 4);
  double CTDU[8 + 1];
  Zero(CTDU, 9);
  double X[8 + 1];
  Zero(X, 9);
  double DHELP1 = 0.0;
  double DHELP2 = 0.0;

  for (int i = 1; i <= 6; i++)
    RM[i][3] = RM[i][2];

  double RM2 = RM[2][3];
  double RM3 = RM[3][3];
  double RM5 = RM[5][3];
  double RMMAX = 0.0;
  int IRMAX = 0;

  for (int i = 1; i <= 6; i++) {
    if (fabs(RM[i][3]) < fabs(RMMAX))
      continue;
    RMMAX = RM[i][3];
    IRMAX = i;
  }

  double HELP1 = RM[1][3] - RMY;
  double HELP2 = RM[4][3] - RMY;
  double HELP3 = RM[6][3] - RMY;
  VEIG(HELP1, RM2, RM3, HELP2, RM5, HELP3, VN);
  HELP1 = RM[1][3] - RMZ;
  HELP2 = RM[4][3] - RMZ;
  HELP3 = RM[6][3] - RMZ;
  VEIG(HELP1, RM2, RM3, HELP2, RM5, HELP3, VE);

  double SE = 0.0;
  double SN = 0.0;
  for (int i = 1; i <= 3; i++) {
    SE += VE[i] * VE[i];
    SN += VN[i] * VN[i];
  }
  SE = sqrt(SE);
  SN = sqrt(SN);
  for (int i = 1; i <= 3; i++) {
    VE[i] = VE[i] / SE;
    VN[i] = VN[i] / SN;
  }

  for (int l = 1; l <= N; l++) {
    double U0 = 0.0;
    double U1 = 0.0;
    for (int i = 1; i <= 3; i++) {
      for (int j = 1; j <= 3; j++) {
        U0 = U0 + double(FIJ[i][j][l] * (VN[i] * VE[j] + VN[j] * VE[i]));
      }
    }
    U1 = U1 + double(U[l]);
    AM0[l] = U1 / U0;
  }

  //C     Finds scalar seismic moment:
  for (int i = 1; i <= 6; i++)
    DD[i] = RM[i][3];
  EIG3(DD, 0, EQM);

  EQM[1] = fabs(EQM[1]) * USMT_DOWNSCALE;
  EQM[2] = fabs(EQM[2]) * USMT_DOWNSCALE;
  EQM[3] = fabs(EQM[3]) * USMT_DOWNSCALE;
  HELP1 = fabs(EQM[1] - EQM[2]);
  HELP2 = fabs(EQM[1] - EQM[3]);
  HELP3 = fabs(EQM[2] - EQM[3]);
  EC = amax1(HELP1, HELP2);
  EC = amax1(EC, HELP3);
  RMT = EC * USMT_UPSCALE;
  RM0 = RMT;

  for (int i = 1; i <= N; i++) {
    for (int j = 1; j <= 6; j++) // error correction
      C[j][i] = 0.0;

    for (int j = 1; j <= 3; j++) {
      for (int k = 1; k <= 3; k++)
        C[k][i] = C[k][i]
            + double(VE[j] * (FIJ[k][j][i] + FIJ[j][k][i])) * AM0[i];
      for (int k = 1; k <= 3; k++)
        C[k + 3][i] = C[k + 3][i]
            + double(VN[j] * (FIJ[k][j][i] + FIJ[j][k][i])) * AM0[i];
    }
  }

  //C     calculate matrix bb and its inverse
  for (int i = 1; i <= 6; i++) {
    for (int j = 1; j <= 6; j++) {
      BB[i][j] = 0.0;
      for (int k = 1; k <= N; k++)
        BB[i][j] = BB[i][j] + C[i][k] * C[j][k];
    }
  }

  for (int i = 1; i <= 3; i++) {
    BB[7][i] = VE[i];
    BB[7][i + 3] = VN[i];
    BB[8][i] = VN[i];
    BB[8][i + 3] = -VE[i];
  }

  BB[7][7] = 0.0;
  BB[7][8] = 0.0;
  BB[8][7] = 0.0;
  BB[8][8] = 0.0;

  for (int i = 1; i <= 8; i++) {
    BB[i][7] = BB[7][i];
    BB[i][8] = BB[8][i];
  }

  for (int i = 1; i <= 8; i++) {
    for (int j = 1; j <= 8; j++) {
      Z1[i][j] = BB[i][j];
    }
  }

  INVMAT(Z1, Z2, 8);

  for (int i = 1; i <= 8; i++) {
    for (int j = 1; j <= 8; j++) {
      BBINV[i][j] = Z2[i][j];
    }
  }

  ICOND = 1;
  double SF = sin(0.01);
  double CF = cos(0.01);

  DE[1] = VE[1] * CF + VE[2] * SF;
  DE[2] = -VE[1] * SF + VE[2] * CF;
  DE[3] = VE[3];
  DN[1] = VN[1] * CF + VN[2] * SF;
  DN[2] = -VN[1] * SF + VN[2] * CF;
  DN[3] = VN[3];

  for (int i = 1; i <= 3; i++) {
    DE[i] = DE[i] - VE[i];
    DN[i] = DN[i] - VN[i];
  }

  double EPS = 1.0e-06;
  int ITER = 1;

  p3012: for (int i = 1; i <= N; i++) {
    DU[i] = 0.0;
    for (int j = 1; j <= 3; j++)
      for (int k = 1; k <= 3; k++)
        DU[i] = DU[i] + double(VN[k] * (FIJ[j][k][i] + FIJ[k][j][i])) * DE[j];
    for (int j = 1; j <= 3; j++)
      for (int k = 1; k <= 3; k++)
        DU[i] = DU[i] + double(VE[k] * (FIJ[j][k][i] + FIJ[k][j][i])) * DN[j];
    DU[i] = DU[i] * AM0[i];
  }

  for (int i = 1; i <= 6; i++) {
    CTDU[i] = 0.0;
    for (int j = 1; j <= N; j++) {
      CTDU[i] = CTDU[i] + C[i][j] * DU[j];
    }
  }

  CTDU[7] = 0.0;
  CTDU[8] = 0.0;

  for (int i = 1; i <= 8; i++) {
    X[i] = 0.0;
    for (int j = 1; j <= 8; j++)
      X[i] = X[i] + BBINV[i][j] * CTDU[j];
  }

  if (ITER == 1000)
    goto p3418;
  if (ITER > 500)
    EPS = 1.0e-03;

  for (int i = 1; i <= 8; i++) {
    if (fabs(X[i]) > 1.0e+99)
      goto p3417;
  }

  for (int i = 1; i <= 3; i++) {
    DHELP1 = fabs(X[i + 3] - DE[i]);
    DHELP2 = fabs(DE[i]) * EPS;
    if (DHELP1 > DHELP2 && fabs(DE[i]) > 1.0e-06)
      goto p3014;
  }

  for (int i = 1; i <= 3; i++) {
    DHELP1 = fabs(X[i] - DN[i]);
    DHELP2 = fabs(DN[i]) * EPS;
    if (DHELP1 > DHELP2 && fabs(DN[i]) > 1.0e-06)
      goto p3014;
  }
  goto p3017;

  p3014: DHELP1 = 0.0;
  DHELP2 = 0.0;

  for (int i = 1; i <= 3; i++) {
    DE[i] = X[i + 3];
    DN[i] = X[i];
    DHELP1 = DHELP1 + DE[i] * DE[i];
    DHELP2 = DHELP2 + DN[i] * DN[i];
  }

  if (DHELP1 >= 1.0 || DHELP2 >= 1.0)
    goto p3417;
  ITER++;
  goto p3012;

  p3418: ICOND = 2;
  goto p3419;

  p3417: ICOND = 3;
  p3419: if (ISTA == 0)
    goto p8887;
#ifdef USMTCORE_DEBUG
  std::cout << "Iteration does not converge - initial eigenvectors used. Double "
  "couple solution may be artificial.";
#endif
  goto p8887;

  p3017: ORT(VE, VN, DE, DN);

  p8887: for (int i = 1; i <= 3; i++) {
    DE[i] = VE[i] + VN[i];
    DN[i] = VN[i] - VE[i];
  }

  double SUME = 0.0;
  double SUMN = 0.0;

  for (int i = 1; i <= 3; i++) {
    SUME = SUME + DE[i] * DE[i];
    SUMN = SUMN + DN[i] * DN[i];
  }

  SUME = sqrt(SUME);
  SUMN = sqrt(SUMN);

  for (int i = 1; i <= 3; i++) {
    VE[i] = DE[i] / SUME;
    VN[i] = DN[i] / SUMN;
  }

  double R1 = RM[1][3];
  double R2 = RM[4][3];
  double R3 = RM[6][3];

  RM[1][3] = 2.0 * VE[1] * VN[1];
  RM[2][3] = VE[1] * VN[2] + VE[2] * VN[1];
  RM[3][3] = VE[1] * VN[3] + VE[3] * VN[1];
  RM[4][3] = 2.0 * VE[2] * VN[2];
  RM[5][3] = VE[2] * VN[3] + VE[3] * VN[2];
  RM[6][3] = 2.0 * VE[3] * VN[3];

  int j = 1;
  if (fabs(R2) > fabs(R1)) {
    j = 4;
    R1 = R2;
  }
  if (fabs(R3) > fabs(R1)) {
    j = 6;
    R1 = R3;
  }
  double HELP = R1 * RM[j][3];
  if (HELP < 0.0) {
    for (int i = 1; i <= 6; i++)
      RM[i][3] = -RM[i][3];
  }
  for (int i = 1; i <= 6; i++)
    RM[i][3] = RM[i][3] * RM0;

  HELP = sign(1.0, RMMAX) * RM[IRMAX][3];
  if (HELP <= 0.0) {
    for (int i = 1; i <= 6; i++)
      RM[i][3] = -RM[i][3];
  }
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::VEIG(double &s1, double &s2, double &s3, double &s4,
    double &s5, double &s6, double v[]) {
  double help0[6 + 1];
  double help1 = 0.0;
  double help2 = 0.0;

  v[1] = 1.0;
  v[2] = 0.0;
  v[3] = 0.0;

  help0[1] = s4 * s6 - s5 * s5;
  help0[2] = s1 * s6 - s3 * s3;
  help0[3] = s1 * s4 - s2 * s2;
  help0[4] = s2 * s5 - s4 * s3;
  help0[5] = s2 * s6 - s3 * s5;
  help0[6] = s1 * s5 - s2 * s3;

  int IMAX = 1;

  for (int i = 2; i <= 6; i++) {
    if (fabs(help0[i]) <= fabs(help0[1]))
      continue;
    help0[1] = help0[i];
    IMAX = i;
  }

  switch (IMAX) {
    case 1:
      help1 = s5 * s3 - s2 * s6;
      help2 = s5 * s2 - s4 * s3;
      v[2] = help1 / help0[1];
      v[3] = help2 / help0[1];
      break;
    case 2:
      v[2] = 1.0;
      help1 = s3 * s5 - s2 * s6;
      help2 = s3 * s2 - s1 * s5;
      v[1] = help1 / help0[1];
      v[3] = help2 / help0[1];
      break;
    case 3:
      v[3] = 1.0;
      help1 = s2 * s5 - s3 * s4;
      help2 = s2 * s3 - s1 * s5;
      v[1] = help1 / help0[1];
      v[2] = help2 / help0[1];
      break;
    case 4:
      v[3] = 1.0;
      help1 = s4 * s6 - s5 * s5;
      help2 = s3 * s5 - s2 * s6;
      v[1] = help1 / help0[1];
      v[2] = help2 / help0[1];
      break;
    case 5:
      v[2] = 1.0;
      help1 = s5 * s5 - s4 * s6;
      help2 = s3 * s4 - s2 * s5;
      v[1] = help1 / help0[1];
      v[3] = help2 / help0[1];
      break;
    case 6:
      v[2] = 1.0;
      help1 = s3 * s4 - s2 * s5;
      help2 = s2 * s2 - s1 * s4;
      v[1] = help1 / help0[1];
      v[3] = help2 / help0[1];
      break;
    default:
      throw;
  }
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::ORT(double VE[], double VN[], double DE[],
    double DN[]) {
  double WE[3 + 1], WN[3 + 1], C[3 + 1], B[3 + 1], V1[3 + 1], V2[3 + 1],
      G[3 + 1];
  Zero(WE, 4);
  Zero(WN, 4);
  Zero(C, 4);
  Zero(B, 4);
  Zero(V1, 4);
  Zero(V2, 4);
  Zero(G, 4);
  double HELP = 0.0;
  double HELP2 = 0.0;

  for (int i = 1; i <= 3; i++) {
    WE[i] = VE[i] + DE[i];
    WN[i] = VN[i] + DN[i];
  }

  HELP = sqrt(WE[1] * WE[1] + WE[2] * WE[2] + WE[3] * WE[3]);
  for (int i = 1; i <= 3; i++)
    WE[i] = WE[i] / HELP;

  HELP = sqrt(WN[1] * WN[1] + WN[2] * WN[2] + WN[3] * WN[3]);
  for (int i = 1; i <= 3; i++)
    WN[i] = WN[i] / HELP;

  HELP = fabs(WE[1] * WN[1] + WE[2] * WN[2] + WE[3] * WN[3]);
  if (HELP > 0.99)
    return;

  for (int i = 1; i <= 3; i++)
    C[i] = 0.5 * (WN[i] + WE[i]);

  B[1] = WN[2] * WE[3] - WN[3] * WE[2];
  B[2] = -WN[1] * WE[3] + WN[3] * WE[1];
  B[3] = WN[1] * WE[2] - WN[2] * WE[1];
  HELP = sqrt(B[1] * B[1] + B[2] * B[2] + B[3] * B[3]);

  for (int i = 1; i <= 3; i++)
    B[i] = B[i] / HELP;

  G[1] = B[2] * C[3] - B[3] * C[2];
  G[2] = -B[1] * C[3] + B[3] * C[1];
  G[3] = B[1] * C[2] - B[2] * C[1];

  for (int i = 1; i <= 3; i++) {
    V1[i] = C[i] + G[i];
    V2[i] = C[i] - G[i];
  }

  HELP = sqrt(V1[1] * V1[1] + V1[2] * V1[2] + V1[3] * V1[3]);

  for (int i = 1; i <= 3; i++)
    V1[i] = V1[i] / HELP;

  HELP = sqrt(V2[1] * V2[1] + V2[2] * V2[2] + V2[3] * V2[3]);
  for (int i = 1; i <= 3; i++)
    V2[i] = V2[i] / HELP;

  HELP = V1[1] * WN[1] + V1[2] * WN[2] + V1[3] * WN[3];
  HELP2 = V2[1] * WN[1] + V2[2] * WN[2] + V2[3] * WN[3];

  if (HELP >= HELP2) {
    for (int i = 1; i <= 3; i++) {
      VN[i] = V1[i];
      VE[i] = V2[i];
    }
  }
  else {
    for (int i = 1; i <= 3; i++) {
      VN[i] = V2[i];
      VE[i] = V1[i];
    }
  }
}

//-----------------------------------------------------------------------------
bool Taquart::UsmtCore::ANGGA(void) {
  const double DETOPI = 4.0 * atan(1.0) / 180.0;
  if (N >= FOCIMT_MIN_ALLOWED_CHANNELS) {
    for (int i = 1; i <= N; i++) {
      double HELP = TKF[i];
      if (HELP == 90.0)
        HELP = 89.75; // Not clear why this constrain is here.
      GA[i][3] = cos(HELP * DETOPI);
      HELP = sqrt(1.0 - GA[i][3] * GA[i][3]);
      GA[i][1] = cos(AZM[i] * DETOPI) * HELP;
      GA[i][2] = sin(AZM[i] * DETOPI) * HELP;
    }
    return true;
  }
  else {
    return false;
  }
}

//-----------------------------------------------------------------------------
bool Taquart::UsmtCore::JEZ(void) {
  //      SUBROUTINE JEZ(IOK)
  //      CHARACTER YN
  //      INTEGER*2 QF
  //      LOGICAL IOK,FSTCLL,USEDAE(212)
  //      COMMON/MDATA/ N,TROZ
  //      COMMON/GAGAGA/ GA(80,3)
  //      COMMON/JEZQUA/ QSD,QF
  //      DIMENSION NDAE(9),DAE(212,3)
  //      DATA FSTCLL,NDAE/.TRUE.,2*36,2*32,2*24,16,8,4/

  bool USEDAE[213];
  double DAE[213][4];
  Zero(&DAE[0][0], 213 * 4);

  //      IOK=.TRUE.

  //      IF(.NOT.FSTCLL) GO TO 10
  if (FSTCLL) {
    //      FSTCLL=.FALSE.
    //      PI=4.*ATAN(1.)
    //      DETOPI=PI/180.
    //      K=0
    FSTCLL = false;
    const double PI = 4.0 * atan(1.0);
    const double DETOPI = PI / 180.0;
    int k = 0;

    //      DO 1 I=1,9
    for (int i = 1; i <= 9; i++) {
      //      ANG=(FLOAT(I-1)*10.+5.)*DETOPI
      double ANG = (double(i - 1) * 10.0 + 5.0) * DETOPI;
      //      DO 2 J=1,NDAE(I)
      for (int j = 1; j <= NDAE[i]; j++) {
        //      K=K+1
        //      DAE(K,3)=SIN(ANG)
        //      SKAL=COS(ANG)
        //      HELP=FLOAT(J)/FLOAT(NDAE(I))*2.*PI
        //      DAE(K,1)=COS(HELP)*SKAL
        //    2 DAE(K,2)=SIN(HELP)*SKAL
        k = k + 1;
        DAE[k][3] = sin(ANG);
        double SKAL = cos(ANG);
        double HELP = double(j) / double(NDAE[i]) * 2.0 * PI;
        DAE[k][1] = cos(HELP) * SKAL;
        DAE[k][2] = sin(HELP) * SKAL;
      }
    }
    //    1 CONTINUE
  }

  //   10 DO 3 I=1,212
  //    3 USEDAE(I)=.TRUE.
  for (int i = 1; i <= 212; i++)
    USEDAE[i] = true;

  //      NLIVE=212
  int NLIVE = 212;

  //      DO 5 I=1,N
  //      DO 5 J=1,212
  for (int i = 1; i <= N; i++) {
    for (int j = 1; j <= 212; j++) {
      //      IF(.NOT.USEDAE(J)) GO TO 5
      if (USEDAE[j] == false)
        continue;

      //      HELP=ABS(GA(I,1)*DAE(J,1)+GA(I,2)*DAE(J,2)+GA(I,3)*DAE(J,3))
      double HELP = fabs(
          GA[i][1] * DAE[j][1] + GA[i][2] * DAE[j][2] + GA[i][3] * DAE[j][3]);

      //      IF(HELP.LT..9659) GO TO 5
      if (HELP < 0.9659)
        continue;

      //      USEDAE(J)=.FALSE.
      //      NLIVE=NLIVE-1
      USEDAE[j] = false;
      NLIVE = NLIVE - 1;
    }
  }
  //    5 CONTINUE

  //      IF(NLIVE.LE.200) GO TO 4
  if (NLIVE <= 200) {
    //    4 SUM1=0.
    //      SUM2=0.
    //      SUM3=0.
    //      SUM4=0.
    //      SUM5=0.
    //      SUM6=0.
    double SUM1 = 0.0, SUM2 = 0.0, SUM3 = 0.0, SUM4 = 0.0, SUM5 = 0.0, SUM6 =
        0.0;

    //      DO 50 I=1,N
    for (int i = 1; i <= N; i++) {
      //      SUM1=SUM1+GA(I,1)*GA(I,1)
      //      SUM2=SUM2+GA(I,1)*GA(I,2)
      //      SUM3=SUM3+GA(I,1)*GA(I,3)
      //      SUM4=SUM4+GA(I,2)*GA(I,2)
      //      SUM5=SUM5+GA(I,2)*GA(I,3)
      //   50 SUM6=SUM6+GA(I,3)*GA(I,3)
      SUM1 = SUM1 + GA[i][1] * GA[i][1];
      SUM2 = SUM2 + GA[i][1] * GA[i][2];
      SUM3 = SUM3 + GA[i][1] * GA[i][3];
      SUM4 = SUM4 + GA[i][2] * GA[i][2];
      SUM5 = SUM5 + GA[i][2] * GA[i][3];
      SUM6 = SUM6 + GA[i][3] * GA[i][3];
    }
    //      QSD=SUM1*SUM4*SUM6+2*SUM2*SUM3*SUM5-SUM3*SUM3*SUM4-
    //     $SUM1*SUM5*SUM5-SUM2*SUM2*SUM6
    //      QSD=ABS(QSD)/FLOAT(N**3)
    //      IF(QF.EQ.2) QSD=1./(1.-ALOG(QSD))
    //      IF(QSD.LT..01) QSD=.01
    QSD = SUM1 * SUM4 * SUM6 + 2 * SUM2 * SUM3 * SUM5 - SUM3 * SUM3 * SUM4
        - SUM1 * SUM5 * SUM5 - SUM2 * SUM2 * SUM6;
    QSD = fabs(QSD) / double(N * N * N);
    if (QF == 2)
      QSD = 1.0 / (1.0 - alog(QSD));
    if (QSD < 0.01)
      QSD = 0.01;
    //      RETURN
    return true;
  }
  else {
    //      WRITE(75,100)
    //  100 FORMAT(' Error: Poor Station distribution.',$)
    //      IOK=.FALSE.
    //	RETURN
    //IOK = false;
    return false; // Poor station distribution!
  }
  //      END
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::PROGRESS(double Progress, double Max) {
  //std::cout << '\r' << Progress / Max * 100 << std::endl;
#ifdef USMTCORE_DEBUG
  std::cout << "|";
  if(Progress == Max)
  std::cout << std::endl;
#endif

  // if (ThreadProgress) *ThreadProgress = int(Progress);

}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::GSOL(double x[], int &iexp) {
  //      subroutine gsol(x,iexp)
  //      dimension x(6),ix(6)
  //      double precision xlo(6),xhi(6),xstep(6),six,size,xtry(6),
  //     $val,try
  //      DATA six,METH/6.D+00,1/
  int ix[6 + 1]; //dimension
  double xlo[6 + 1];
  Zero(xlo, 7);
  double xhi[6 + 1];
  Zero(xhi, 7);
  double xstep[6 + 1];
  Zero(xstep, 7);
  double six = 6.0e+00;
  double xtry[6 + 1];
  double val = 0.0;
  double tryy = 0.0;
  //int METH = 1;
  //double size = 0.0;

  //      IF((IEXP.LT.10).OR.(IEXP.GT.30)) IEXP=20
  if (iexp < 10 || iexp > 30)
    iexp = 20;

  //      iter=0
  //      jter=1
  //      val=1.d+30
  int iter = 0;
  //int jter = 1;
  val = 1.0e+30;

  //      do 1 i=1,6
  //      xlo(i)=DBLE(-1.*10.**IEXP)
  //      xhi(i)=DBLE(10.**IEXP)
  //    1 ix(i)=0
  for (int i = 1; i <= 6; i++) {
    xlo[i] = -1.0 * pow(10.0, iexp);
    xhi[i] = pow(10.0, iexp);
    ix[i] = 0;
  }

  //      DO 8 L=1,50
  for (int l = 1; l <= 50; l++) {
    PROGRESS(l, 350);
    //      do 2 i=1,6
    //    2 xstep(i)=(xhi(i)-xlo(i))/SIX
    for (int i = 1; i <= 6; i++)
      xstep[i] = (xhi[i] - xlo[i]) / six;

    //      size=xhi(1)-xlo(1)
    //      iter=iter+1
    //size = xhi[1] - xlo[1];
    iter = iter + 1;

    //      do 3 j1=1,7
    for (int j1 = 1; j1 <= 7; j1++) {
      //      xtry(1)=xlo(1)+DBLE(j1-1)*xstep(1)
      //      CALL POSTEP(METH,JTER,J1)
      xtry[1] = xlo[1] + double(j1 - 1) * xstep[1];
      //POSTEP(METH,jter,j1);

      //      do 3 j2=1,7
      for (int j2 = 1; j2 <= 7; j2++) {
        //      xtry(2)=xlo(2)+DBLE(j2-1)*xstep(2)
        xtry[2] = xlo[2] + double(j2 - 1) * xstep[2];

        //      do 3 j3=1,7
        for (int j3 = 1; j3 <= 7; j3++) {
          //      xtry(3)=xlo(3)+DBLE(j3-1)*xstep(3)
          xtry[3] = xlo[3] + double(j3 - 1) * xstep[3];

          //      do 3 j4=1,7
          for (int j4 = 1; j4 <= 7; j4++) {
            //      xtry(4)=xlo(4)+DBLE(j4-1)*xstep(4)
            xtry[4] = xlo[4] + double(j4 - 1) * xstep[4];

            //      do 3 j5=1,7
            for (int j5 = 1; j5 <= 7; j5++) {
              //      xtry(5)=xlo(5)+DBLE(j5-1)*xstep(5)
              xtry[5] = xlo[5] + double(j5 - 1) * xstep[5];

              //      do 3 j6=1,7
              for (int j6 = 1; j6 <= 7; j6++) {
                //      xtry(6)=xlo(6)+DBLE(j6-1)*xstep(6)
                xtry[6] = xlo[6] + double(j6 - 1) * xstep[6];
                //      call f1(xtry,try)
                f1(xtry, tryy);

                //      if(try.gt.val) go to 3
                if (tryy > val)
                  continue;

                //      val=try
                //      ix(1)=j1
                //      ix(2)=j2
                //      ix(3)=j3
                //      ix(4)=j4
                //      ix(5)=j5
                //      ix(6)=j6
                val = tryy;
                ix[1] = j1;
                ix[2] = j2;
                ix[3] = j3;
                ix[4] = j4;
                ix[5] = j5;
                ix[6] = j6;

                //      do 12 i=1,6
                //   12 x(i)=SNGL(xtry(i))
                for (int i = 1; i <= 6; i++)
                  x[i] = xtry[i];
              }
            }
          }
        }
      }
    }
    //    3 CONTINUE

    //      DO 4 I=1,6
    //      xhi(i)=xlo(i)+DBLE(ix(i)+1)*xstep(i)
    //    4 xlo(i)=xlo(i)+DBLE(ix(i)-3)*xstep(i)
    for (int i = 1; i <= 6; i++) {
      xhi[i] = xlo[i] + (ix[i] + 1) * xstep[i];
      xlo[i] = xlo[i] + (ix[i] - 3) * xstep[i];
    }
  }
  //    8 CONTINUE
  //      return
  //      end
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::f1(double X[], double &fff) {
  fff = 0.0;
  for (int i = 1; i <= N; i++) {
    double sum = 0.0;
    for (int j = 1; j <= 6; j++) {
      sum = sum + A[i][j] * X[j];
    }
    fff = fff + fabs(sum - U[i]);
  }
  if (fabs(fff) > 1e+30)
    fff = 1e+30;
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::GSOL5(double x[], int &IEXP) {
  //      subroutine gsol5(x,IEXP)
  //      dimension x(5),ix(5)
  //      double precision xlo(5),xhi(5),xstep(5),six,size,xtry(5),VAL,TRY
  //      DATA SIX,METH/6.D+0,2/
  double xlo[8], xhi[8], xstep[8], six = 6.0, xtry[8], VAL = 0.0, TRY = 0.0;
  //int METH = 2;
  int ix[7];

  //      IF((IEXP.LT.10).OR.(IEXP.GT.30)) IEXP=20
  //      iter=0
  //      jter=1
  //      val=1.d+30
  if (IEXP < 10 || IEXP > 30)
    IEXP = 20;
  int iter = 0;
  //int jter = 1;
  VAL = 1.0e+30;

  //      do 1 i=1,5
  for (int i = 1; i <= 5; i++) {
    //      xlo(i)=DBLE(-1.*10.**IEXP)
    //      xhi(i)=DBLE(10.**IEXP)
    xlo[i] = -1.0 * pow(10.0, double(IEXP));
    xhi[i] = pow(10.0, double(IEXP));
    ix[i] = 0;
  }
  //    1 ix(i)=0

  //      DO 8 L=1,50
  for (int l = 1; l <= 50; l++) {
    PROGRESS(l + 50, 350);

    //      do 2 i=1,5
    //    2 xstep(i)=(xhi(i)-xlo(i))/six
    for (int i = 1; i <= 5; i++)
      xstep[i] = (xhi[i] - xlo[i]) / six;

    //      size=xhi(1)-xlo(1)
    //      iter=iter+1
    //      do 3 j1=1,7
    //size = xhi[1] - xlo[1];
    iter = iter + 1;
    for (int j1 = 1; j1 <= 7; j1++) {
      //      xtry(1)=xlo(1)+DBLE(j1-1)*xstep(1)
      //      CALL POSTEP(METH,JTER,J1)
      xtry[1] = xlo[1] + double(j1 - 1) * xstep[1];
      //POSTEP(METH,jter,j1);

      //      do 3 j2=1,7
      for (int j2 = 1; j2 <= 7; j2++) {
        //      xtry(2)=xlo(2)+DBLE(j2-1)*xstep(2)
        //      do 3 j3=1,7
        xtry[2] = xlo[2] + double(j2 - 1) * xstep[2];
        for (int j3 = 1; j3 <= 7; j3++) {
          //      xtry(3)=xlo(3)+DBLE(j3-1)*xstep(3)
          //      do 3 j4=1,7
          xtry[3] = xlo[3] + double(j3 - 1) * xstep[3];
          for (int j4 = 1; j4 <= 7; j4++) {
            //      xtry(4)=xlo(4)+DBLE(j4-1)*xstep(4)
            //      do 3 j5=1,7
            xtry[4] = xlo[4] + double(j4 - 1) * xstep[4];
            for (int j5 = 1; j5 <= 7; j5++) {
              //      xtry(5)=xlo(5)+DBLE(j5-1)*xstep(5)
              //      call f2(xtry,try)
              xtry[5] = xlo[5] + double(j5 - 1) * xstep[5];
              f2(xtry, TRY);

              //      if(try.gt.val) go to 3
              if (TRY > VAL)
                continue;

              //      val=try
              //      ix(1)=j1
              //      ix(2)=j2
              //      ix(3)=j3
              //      ix(4)=j4
              //      ix(5)=j5
              //      do 12 i=1,5
              //   12 x(i)=SNGL(Xtry(i))
              VAL = TRY;
              ix[1] = j1;
              ix[2] = j2;
              ix[3] = j3;
              ix[4] = j4;
              ix[5] = j5;
              for (int i = 1; i <= 5; i++) {
                x[i] = xtry[i];
              }
            }
          }
        }
      }
    }
    //    3 CONTINUE
    //      DO 4 I=1,5
    //      xhi(i)=xlo(i)+DBLE(ix(i)+1)*xstep(i)
    //    4 xlo(i)=xlo(i)+DBLE(ix(i)-3)*xstep(i)
    for (int i = 1; i <= 5; i++) {
      xhi[i] = xlo[i] + double(ix[i] + 1) * xstep[i];
      xlo[i] = xlo[i] + double(ix[i] - 3) * xstep[i];
    }
  }
  //    8 CONTINUE
  //      return
  //      end
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::GSOLA(double x[], int &IEXP) {
  //      subroutine gsola(x,IEXP)
  //      double precision xlo(4),xhi(4),xstep(4),xtry(5),FOUR,SIZE,SIX,val,try,help,y(5),del,two,ZERO
  //      dimension x(5),ix(4),xmem(5,5),vmem(5)
  //      DATA TWO,FOUR,METH,SIX/2.D+0,4.D+0,3,6.D+0/

  double xlo[4 + 1];
  Zero(xlo, 5);
  double xhi[4 + 1];
  Zero(xhi, 5);
  double xstep[4 + 1];
  Zero(xstep, 5);
  double xtry[5 + 1];
  Zero(xtry, 6);
  double FOUR = 4.0, SIX = 6.0, val = 0.0, tryy = 0.0;
  double help, y[5 + 1], DEL = 0.0, TWO = 2.0;
  int ix[4 + 1];
  double xmem[5 + 1][5 + 1], vmem[5 + 1];
  Zero(&xmem[0][0], 36);
  Zero(vmem, 6);

  if (IEXP < 10 || IEXP > 30)
    IEXP = 20;
  double ZERO = 0.0;
  int iter = 0;
  for (int i = 1; i <= 5; i++) {
    vmem[i] = 1.0e+30;
    for (int j = 1; j <= 5; j++)
      xmem[i][j] = 0.0;
  }

  //C     Search for X1,X2,X3,X4; X5 is calculated:
  val = 1e+30;
  for (int i = 1; i <= 4; i++) {
    xlo[i] = -1.0 * pow(10.0, IEXP);
    xhi[i] = pow(10.0, IEXP);
    ix[i] = 0;
  }

  for (int l = 1; l <= 50; l++) {
    PROGRESS(l + 100, 350);
    for (int i = 1; i <= 4; i++)
      xstep[i] = (xhi[i] - xlo[i]) / SIX;

    iter++;
    xtry[5] = 0.0;

    for (int j1 = 1; j1 <= 7; j1++) {
      xtry[1] = xlo[1] + double(j1 - 1) * xstep[1];
      for (int j2 = 1; j2 <= 7; j2++) {
        xtry[2] = xlo[2] + double(j2 - 1) * xstep[2];
        for (int j3 = 1; j3 <= 7; j3++) {
          xtry[3] = xlo[3] + double(j3 - 1) * xstep[3];
          for (int j4 = 1; j4 <= 7; j4++) {
            xtry[4] = xlo[4] + double(j4 - 1) * xstep[4];
            if (fabs(xtry[1]) < 1.0e-6)
              goto p23;
            for (int i = 1; i <= 5; i++)
              y[i] = xtry[i] * 1.0e-10;
            DEL = pow(TWO * y[2] * y[3], 2.0)
                + FOUR * y[1]
                    * (y[4]
                        * (-pow(y[1], 2.0) - y[1] * y[4] - pow(y[3], 2.0)
                            + pow(y[2], 2.0)) + pow(y[2], 2.0) * y[1]);
            if (DEL < ZERO)
              continue;
            DEL = sqrt(DEL);
            y[5] = (TWO * y[2] * y[3] + DEL) / TWO / y[1];
            xtry[5] = y[5] * 1.0e+10;
            f2(xtry, tryy);
            if (tryy > val)
              goto p22;
            RENUM(tryy, val, ix, j1, j2, j3, j4);
            for (int i = 1; i <= 5; i++)
              x[i] = double(xtry[i]);
            p22: y[5] = (TWO * y[2] * y[3] - DEL) / TWO / y[1];
            xtry[5] = y[5] * 1.0e+10;
            f2(xtry, tryy);
            if (tryy > val)
              continue;
            RENUM(tryy, val, ix, j1, j2, j3, j4);
            for (int i = 1; i <= 5; i++)
              x[i] = double(xtry[i]);
            continue;
            p23: if (fabs(xtry[2]) < 1.0e-6 || fabs(xtry[3]) < 1.0e-6)
              continue;
            for (int i = 1; i <= 5; i++)
              y[i] = xtry[i] * 1.0e-10;
            DEL = y[4]
                * (-pow(y[1], 2.0) - y[1] * y[4] - pow(y[3], 2.0)
                    + pow(y[2], 2.0)) + pow(y[2], 2.0) * y[1];
            y[5] = -DEL / TWO / y[3] / y[2];
            xtry[5] = y[5] * 1.0e+10;
            f2(xtry, tryy);
            if (tryy > val)
              continue;
            RENUM(tryy, val, ix, j1, j2, j3, j4);
            for (int i = 1; i <= 5; i++)
              x[i] = double(xtry[i]);
          }
        }
      }
    }

    if (val == 1e+30)
      goto p30;
    for (int i = 1; i <= 4; i++) {
      xhi[i] = xlo[i] + double(ix[i] + 1) * xstep[i];
      xlo[i] = xlo[i] + double(ix[i] - 3) * xstep[i];
    }
  }
  for (int i = 1; i <= 5; i++)
    xmem[1][i] = x[i];
  vmem[1] = val;

  //C     Search for X1,X2,X3,X5; X4 is calculated:
  p30: val = 1.0e+30;
  for (int i = 1; i <= 4; i++) {
    xlo[i] = -1.0 * pow(10, IEXP);
    xhi[i] = pow(10, IEXP);
    ix[i] = 0;
  }

  for (int l = 1; l <= 50; l++) {
    PROGRESS(l + 150, 350);
    for (int i = 1; i <= 4; i++)
      xstep[i] = (xhi[i] - xlo[i]) / SIX;

    iter++;
    xtry[4] = 0.0;

    for (int j1 = 1; j1 <= 7; j1++) {
      xtry[1] = xlo[1] + double(j1 - 1) * xstep[1];
      for (int j2 = 1; j2 <= 7; j2++) {
        xtry[2] = xlo[2] + double(j2 - 1) * xstep[2];
        for (int j3 = 1; j3 <= 7; j3++) {
          xtry[3] = xlo[3] + double(j3 - 1) * xstep[3];
          for (int j4 = 1; j4 <= 7; j4++) {
            xtry[5] = xlo[4] + double(j4 - 1) * xstep[4];
            if (fabs(xtry[1]) < 1.0e-06)
              goto p123;
            for (int i = 1; i <= 5; i++)
              y[i] = xtry[i] * 1.0e-10;
            DEL = pow(-pow(y[1], 2.0) - pow(y[3], 2.0) + pow(y[2], 2.0), 2.0)
                + FOUR * y[1]
                    * (TWO * y[2] * y[3] * y[5] - y[1] * pow(y[5], 2.0)
                        + y[1] * pow(y[2], 2.0));
            if (DEL < ZERO)
              continue;

            DEL = sqrt(DEL);
            y[4] = (-pow(y[1], 2.0) - pow(y[3], 2.0) + pow(y[2], 2.0) + DEL)
                / TWO / y[1];
            xtry[4] = y[4] * 1.0e+10;
            f2(xtry, tryy);

            if (tryy <= val) {
              RENUM(tryy, val, ix, j1, j2, j3, j4);
              for (int i = 1; i <= 5; i++)
                x[i] = xtry[i];
            }

            y[4] = (-pow(y[1], 2.0) - pow(y[3], 2.0) + pow(y[2], 2.0) - DEL)
                / TWO / y[1];

            xtry[4] = y[4] * 1.0e+10;
            f2(xtry, tryy);
            if (tryy > val)
              continue;
            RENUM(tryy, val, ix, j1, j2, j3, j4);

            //      DO 125 i=1,5
            //  125 x(i)=SNGL(xtry(i))
            //      go to 103
            for (int i = 1; i <= 5; i++)
              x[i] = xtry[i];

            continue; // TODO: It's not clear what is the side effects of this line, test!

            p123: for (int i = 1; i <= 5; i++)
              y[i] = xtry[i] * 1.0e-10;

            help = -pow(y[1], 2.0) - pow(y[3], 2.0) + pow(y[2], 2.0);
            if (fabs(help) < 1.0e-20)
              continue;
            DEL = TWO * y[2] * y[3] * y[5] - y[5] * y[5] * y[1]
                + y[2] * y[2] * y[1];

            y[4] = -DEL / help;
            xtry[4] = y[4] * 1.0e+10;
            f2(xtry, tryy);

            if (tryy <= val) {
              RENUM(tryy, val, ix, j1, j2, j3, j4);
              for (int i = 1; i <= 5; i++)
                x[i] = xtry[i];
            }
          }
        }
      }
    }

    if (val == 1.0e+30)
      goto p130;
    for (int i = 1; i <= 4; i++) {
      xhi[i] = xlo[i] + double(ix[i] + 1) * xstep[i];
      xlo[i] = xlo[i] + double(ix[i] - 3) * xstep[i];
    }
  }
  for (int i = 1; i <= 5; i++)
    xmem[2][i] = x[i];
  vmem[2] = val;

  //C     Search for X1,X2,X4,X5; X3 is calculated:
  p130: val = 1.0e+30;

  for (int i = 1; i <= 4; i++) {
    xlo[i] = -1.0 * pow(10, IEXP);
    xhi[i] = pow(10, IEXP);
    ix[i] = 0;
  }

  for (int l = 1; l <= 50; l++) {
    PROGRESS(l + 200, 350);
    for (int i = 1; i <= 4; i++)
      xstep[i] = (xhi[i] - xlo[i]) / SIX;

    iter++;
    xtry[3] = 0.0;
    //POSTEP(METH,jter,j7);

    for (int j1 = 1; j1 <= 7; j1++) {
      xtry[1] = xlo[1] + double(j1 - 1) * xstep[1];
      for (int j2 = 1; j2 <= 7; j2++) {
        xtry[2] = xlo[2] + double(j2 - 1) * xstep[2];
        for (int j3 = 1; j3 <= 7; j3++) {
          xtry[4] = xlo[3] + double(j3 - 1) * xstep[3];
          for (int j4 = 1; j4 <= 7; j4++) {
            xtry[5] = xlo[4] + double(j4 - 1) * xstep[4];
            if (fabs(xtry[4]) < 1.0e-06)
              goto p223;

            for (int i = 1; i <= 5; i++)
              y[i] = xtry[i] * 1.0e-10;

            DEL = pow(TWO * y[2] * y[5], 2.0)
                + FOUR * y[4]
                    * (-y[1] * y[1] * y[4] - y[1] * y[4] * y[4]
                        - y[5] * y[5] * y[1] + y[2] * y[2] * y[1]
                        + y[2] * y[2] * y[4]);

            if (DEL < ZERO)
              continue;

            DEL = sqrt(DEL);
            y[3] = (TWO * y[2] * y[5] + DEL) / TWO / y[4];
            xtry[3] = y[3] * 1.0e+10;
            f2(xtry, tryy);

            if (tryy <= val) {
              RENUM(tryy, val, ix, j1, j2, j3, j4);
              for (int i = 1; i <= 5; i++)
                x[i] = xtry[i];
            }

            y[3] = (TWO * y[2] * y[5] - DEL) / TWO / y[4];

            xtry[3] = y[3] * 1.0e+10;
            f2(xtry, tryy);
            if (tryy > val)
              continue;
            RENUM(tryy, val, ix, j1, j2, j3, j4);

            for (int i = 1; i <= 5; i++)
              x[i] = xtry[i];
            continue; // TODO: It's not clear what is the purpose of this line.

            p223: if (fabs(xtry[2]) < 1.0e-6 || fabs(xtry[5]) < 1.0e-06)
              continue;

            for (int i = 1; i <= 5; i++)
              y[i] = xtry[i] * 1.0e-10;

            DEL = -y[1] * y[1] * y[4] - y[1] * y[4] * y[4] - y[5] * y[5] * y[1]
                + y[2] * y[2] * (y[1] + y[4]);

            y[3] = -DEL / TWO / y[2] / y[5];
            xtry[3] = y[3] * 1.0e+10;
            f2(xtry, tryy);

            if (tryy <= val) {
              RENUM(tryy, val, ix, j1, j2, j3, j4);
              for (int i = 1; i <= 5; i++)
                x[i] = double(xtry[i]);
            }
          }
        }
      }
    }

    if (val == 1.0e+30)
      goto p230;
    for (int i = 1; i <= 4; i++) {
      xhi[i] = xlo[i] + double(ix[i] + 1) * xstep[i];
      xlo[i] = xlo[i] + double(ix[i] - 3) * xstep[i];
    }
  }

  for (int i = 1; i <= 5; i++)
    xmem[3][i] = x[i];
  vmem[3] = val;

  //C     Search for X1,X3,X4,X5; X2 is calculated:

  p230: val = 1.0e+30;
  for (int i = 1; i <= 4; i++) {
    xlo[i] = -1.0 * pow(10, IEXP);
    xhi[i] = pow(10, IEXP);
    ix[i] = 0;
  }

  for (int l = 1; l <= 50; l++) {
    PROGRESS(l + 250, 350);
    for (int i = 1; i <= 4; i++)
      xstep[i] = (xhi[i] - xlo[i]) / SIX;

    iter++;
    xtry[2] = 0.0;
    //POSTEP(METH,jter,j7);

    for (int j1 = 1; j1 <= 7; j1++) {
      xtry[1] = xlo[1] + double(j1 - 1) * xstep[1];
      for (int j2 = 1; j2 <= 7; j2++) {
        xtry[3] = xlo[2] + double(j2 - 1) * xstep[2];
        for (int j3 = 1; j3 <= 7; j3++) {
          xtry[4] = xlo[3] + double(j3 - 1) * xstep[3];
          for (int j4 = 1; j4 <= 7; j4++) {
            xtry[5] = xlo[4] + double(j4 - 1) * xstep[4];
            if (fabs(xtry[4] + xtry[1]) < 1.0e-06)
              goto p323;

            for (int i = 1; i <= 5; i++)
              y[i] = xtry[i] * 1.0e-10;

            DEL = pow(TWO * y[3] * y[5], 2.0)
                - FOUR * (y[1] + y[4])
                    * (-y[1] * y[1] * y[4] - y[1] * y[4] * y[4]
                        - y[5] * y[5] * y[1] - y[3] * y[3] * y[4]);

            if (DEL < ZERO)
              continue;

            DEL = sqrt(DEL);
            y[2] = (-TWO * y[3] * y[5] - DEL) / TWO / (y[1] + y[4]);
            xtry[2] = y[2] * 1.0e+10;
            f2(xtry, tryy);

            if (tryy <= val) {
              RENUM(tryy, val, ix, j1, j2, j3, j4);
              for (int i = 1; i <= 5; i++)
                x[i] = xtry[i];
            }

            y[2] = (-TWO * y[3] * y[5] + DEL) / TWO / (y[1] + y[4]);
            xtry[2] = y[2] * 1.0e+10;
            f2(xtry, tryy);

            if (tryy > val)
              continue;
            RENUM(tryy, val, ix, j1, j2, j3, j4);

            for (int i = 1; i <= 5; i++)
              x[i] = xtry[i];
            continue;

            p323: if (fabs(xtry[3]) < 1.0e-06 || fabs(xtry[5]) < 1.0e-06)
              continue;

            for (int i = 1; i <= 5; i++)
              y[i] = xtry[i] * 1.0e-10;

            DEL = -y[1] * y[1] * y[4] - y[1] * y[4] * y[4] - y[5] * y[5] * y[1]
                - y[3] * y[3] * y[4];

            y[2] = -DEL / TWO / y[3] / y[5];
            xtry[2] = y[2] * 1.0e+10;
            f2(xtry, tryy);

            if (tryy <= val) {
              RENUM(tryy, val, ix, j1, j2, j3, j4);
              for (int i = 1; i <= 5; i++)
                x[i] = xtry[i];
            }
          }
        }
      }
    }
    if (val == 1.0e+30)
      goto p330;
    for (int i = 1; i <= 4; i++) {
      xhi[i] = xlo[i] + double(ix[i] + 1) * xstep[i];
      xlo[i] = xlo[i] + double(ix[i] - 3) * xstep[i];
    }
  }
  for (int i = 1; i <= 5; i++)
    xmem[4][i] = x[i];
  vmem[4] = val;

  p330: val = 1.0e+30;
  for (int i = 1; i <= 4; i++) {
    xlo[i] = -1.0 * pow(10, IEXP);
    xhi[i] = pow(10, IEXP);
    ix[i] = 0;
  }

  for (int l = 1; l <= 50; l++) {
    PROGRESS(l + 300, 350);
    for (int i = 1; i <= 4; i++)
      xstep[i] = (xhi[i] - xlo[i]) / SIX;

    iter++;
    xtry[1] = 0.0; /* Corrected 2006.10.05 */

    for (int j1 = 1; j1 <= 7; j1++) {
      xtry[2] = xlo[1] + double(j1 - 1) * xstep[1];
      for (int j2 = 1; j2 <= 7; j2++) {
        xtry[2] = xlo[2] + double(j2 - 1) * xstep[2];
        for (int j3 = 1; j3 <= 7; j3++) {
          xtry[3] = xlo[3] + double(j3 - 1) * xstep[3];
          for (int j4 = 1; j4 <= 7; j4++) {
            xtry[5] = xlo[4] + double(j4 - 1) * xstep[4];

            if (fabs(xtry[4]) < 1.0e-06)
              goto p423;

            for (int i = 1; i <= 5; i++)
              y[i] = xtry[i] * 1.0e-10;

            DEL = pow(-y[4] * y[4] - y[5] * y[5] + y[2] * y[2], 2.0)
                + FOUR * y[4]
                    * (TWO * y[2] * y[3] * y[5] - y[4] * y[3] * y[3]
                        + y[4] * y[2] * y[2]);

            if (DEL < ZERO)
              continue;

            DEL = sqrt(DEL);
            y[1] = (-y[4] * y[4] - y[5] * y[5] + y[2] * y[2] + DEL) / TWO
                / y[4];
            xtry[1] = y[1] * 1.0e+10;
            f2(xtry, tryy);

            if (tryy <= val) {
              RENUM(tryy, val, ix, j1, j2, j3, j4);
              for (int i = 1; i <= 5; i++)
                x[i] = xtry[i];
            }

            y[1] = (-y[4] * y[4] - y[5] * y[5] + y[2] * y[2] - DEL) / TWO
                / y[4];

            xtry[1] = y[1] * 1.0e+10;
            f2(xtry, tryy);
            if (tryy > val)
              continue;
            RENUM(tryy, val, ix, j1, j2, j3, j4);

            for (int i = 1; i <= 5; i++)
              x[i] = xtry[i];
            continue;
            p423: for (int i = 1; i <= 5; i++)
              y[i] = xtry[i] * 1.0e-10;

            help = -pow(y[4], 2.0) - pow(y[5], 2.0) + pow(y[2], 2.0);
            if (fabs(help) < 1.0e-20)
              continue;
            DEL = TWO * y[2] * y[3] * y[5] - y[3] * y[3] * y[4]
                + y[2] * y[2] * y[4];

            y[1] = -DEL / help;
            xtry[1] = y[1] * 1.0e+10;
            f2(xtry, tryy);
            if (tryy <= val) {
              RENUM(tryy, val, ix, j1, j2, j3, j4);
              for (int i = 1; i <= 5; i++)
                x[i] = xtry[i];
            }
          }
        }
      }
    }

    if (val == 1.0e+30)
      goto p430;
    for (int i = 1; i <= 4; i++) {
      xhi[i] = xlo[i] + double(ix[i] + 1) * xstep[i];
      xlo[i] = xlo[i] + double(ix[i] - 3) * xstep[i];
    }
  }
  for (int i = 1; i <= 5; i++)
    xmem[5][i] = x[i];
  vmem[5] = val;

  p430: for (int i = 1; i <= 4; i++) {
    if (vmem[i] > vmem[5])
      break;
    vmem[5] = vmem[i];
    for (int j = 1; j <= 5; j++)
      x[j] = xmem[i][j];
  }
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::f2(double x[], double &ffg) {
  ffg = 0.0;
  double SUM = 0.0;
  for (int i = 1; i <= N; i++) {
    SUM = 0.0;
    for (int j = 1; j <= 5; j++)
      SUM += (A[i][j] * x[j]);
    SUM -= (A[i][6] * (x[1] + x[4]));
    ffg += fabs(SUM - U[i]);
  }
  if (fabs(ffg) > 1.0e+30)
    ffg = 1.0e+30;
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::POSTEP(int &METH, int &ITER, int &IND1) {
  int NCALL = 0;

  if (ITER <= 1) {
#ifdef USMTCORE_DEBUG
    double R = 0.0;
    double PERC = 0.0;
#endif
    switch (METH) {
      case 1:
#ifdef USMTCORE_DEBUG
        R = double(IND1 / 7.0);
        PERC = 2.0 * (double(ITER - 1) + R);
#endif
        break;
      case 2:
#ifdef USMTCORE_DEBUG
        R = double(IND1 / 7.0);
        PERC = 2.0 * (double(ITER - 1) + R);
#endif
        break;
      case 3:
#ifdef USMTCORE_DEBUG
        R = double(IND1 / 7.0);
        PERC = 0.4 * (double(ITER - 1) + R);
#endif
        break;
    }
#ifdef USMTCORE_DEBUG
    std::cout << "Method " << METH << " ( " << PERC << "% blocks )" << std::endl;
#endif
    ITER = 100;
    NCALL = 1;
    return;
  }

  if (NCALL != 73) {
#ifdef USMTCORE_DEBUG
    std::cout << "|";
#endif
    NCALL++;
  }
  else {
#ifdef USMTCORE_DEBUG
    std::cout << "|!";
#endif
    NCALL = 1;
  }
}

//-----------------------------------------------------------------------------
double Taquart::UsmtCore::DETR(double T[], double X) {
  double S[6 + 1];
  double SKAL = fabs(T[1]) + fabs(T[2]) + fabs(T[3]) + fabs(T[4]) + fabs(T[5])
      + fabs(T[6]);
  if (SKAL < 1.0)
    SKAL = 1.0;
  for (int i = 1; i <= 6; i++)
    S[i] = T[i] / SKAL;
  double Y = X / SKAL;
  return (S[1] - Y) * (S[4] - Y) * (S[6] - Y) + 2.0 * S[2] * S[3] * S[5]
      - S[2] * S[2] * (S[6] - Y) - S[3] * S[3] * (S[4] - Y)
      - S[5] * S[5] * (S[1] - Y);
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::RENUM(double &TRY, double &VAL, int ix[], int &j1,
    int &j2, int &j3, int &j4) {
  VAL = TRY;
  ix[1] = j1;
  ix[2] = j2;
  ix[3] = j3;
  ix[4] = j4;
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::RDINP(Taquart::SMTInputData &InputData) {
  N = InputData.Count();
  TROZ = InputData.GetRuptureTime();
  Taquart::SMTInputLine InputLine;
  for (int i = 1; i <= N; i++) {
    //RPSTID[i] = i-1;
    //KNID[i] = i-1;
    //RPSTCP[i] = 'Z';
    //PS[i] = ' ';
    InputData.Get(i - 1, InputLine);
    U[i] = InputLine.Displacement;
    //ARR[i] = InputLine.Incidence; /* Code for SV and SH is switched off by default. */
    AZM[i] = InputLine.Azimuth;
    TKF[i] = InputLine.TakeOff;
    RO[i] = InputLine.Density;
    VEL[i] = InputLine.Velocity;
    R[i] = InputLine.Distance;
    Station[i] = InputLine.Name;
    //ACTIV[i] = 1;
  }
}

//-----------------------------------------------------------------------------
void Taquart::UsmtCore::SIZEMM(int &IEXP) {
  double X = 0.0;
  for (int i = 1; i <= 6; i++) {
    X = amax1(X, fabs(RM[i][2]));
  }
  X = 10.0 * X;
  IEXP = int(alog10(X)) + 1;
}

//-----------------------------------------------------------------------------

